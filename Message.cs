// Generated by ProtoGen, Version=2.4.1.555, Culture=neutral, PublicKeyToken=17b3b1f090c3ea48.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace MessageStruct {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class Message {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    internal static pbd::MessageDescriptor internal__static_MessageStruct_Echo__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.Echo, global::MessageStruct.Echo.Builder> internal__static_MessageStruct_Echo__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_LogOnorOut__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.LogOnorOut, global::MessageStruct.LogOnorOut.Builder> internal__static_MessageStruct_LogOnorOut__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_ImageVersion__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.ImageVersion, global::MessageStruct.ImageVersion.Builder> internal__static_MessageStruct_ImageVersion__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_ReplyStatus__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.ReplyStatus, global::MessageStruct.ReplyStatus.Builder> internal__static_MessageStruct_ReplyStatus__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_Register__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.Register, global::MessageStruct.Register.Builder> internal__static_MessageStruct_Register__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_ChessBoardUser__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.ChessBoardUser, global::MessageStruct.ChessBoardUser.Builder> internal__static_MessageStruct_ChessBoardUser__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_ChessBoardInfoReq__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.ChessBoardInfoReq, global::MessageStruct.ChessBoardInfoReq.Builder> internal__static_MessageStruct_ChessBoardInfoReq__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_ChessBoardInfo__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.ChessBoardInfo, global::MessageStruct.ChessBoardInfo.Builder> internal__static_MessageStruct_ChessBoardInfo__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_HallInfoReq__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.HallInfoReq, global::MessageStruct.HallInfoReq.Builder> internal__static_MessageStruct_HallInfoReq__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_HallInfo__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.HallInfo, global::MessageStruct.HallInfo.Builder> internal__static_MessageStruct_HallInfo__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_GameHallSumaryReq__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.GameHallSumaryReq, global::MessageStruct.GameHallSumaryReq.Builder> internal__static_MessageStruct_GameHallSumaryReq__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_GameHallSumary__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.GameHallSumary, global::MessageStruct.GameHallSumary.Builder> internal__static_MessageStruct_GameHallSumary__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_RequestPlay__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.RequestPlay, global::MessageStruct.RequestPlay.Builder> internal__static_MessageStruct_RequestPlay__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_RequestPlayReply__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.RequestPlayReply, global::MessageStruct.RequestPlayReply.Builder> internal__static_MessageStruct_RequestPlayReply__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_MoveChess__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.MoveChess, global::MessageStruct.MoveChess.Builder> internal__static_MessageStruct_MoveChess__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_MoveAction__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.MoveAction, global::MessageStruct.MoveAction.Builder> internal__static_MessageStruct_MoveAction__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_UserMessage__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.UserMessage, global::MessageStruct.UserMessage.Builder> internal__static_MessageStruct_UserMessage__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_SystemMessage__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.SystemMessage, global::MessageStruct.SystemMessage.Builder> internal__static_MessageStruct_SystemMessage__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_Reconciled__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.Reconciled, global::MessageStruct.Reconciled.Builder> internal__static_MessageStruct_Reconciled__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_GiveUp__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.GiveUp, global::MessageStruct.GiveUp.Builder> internal__static_MessageStruct_GiveUp__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_Undo__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.Undo, global::MessageStruct.Undo.Builder> internal__static_MessageStruct_Undo__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_GameReadyReq__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.GameReadyReq, global::MessageStruct.GameReadyReq.Builder> internal__static_MessageStruct_GameReadyReq__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_GameStatusReply__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.GameStatusReply, global::MessageStruct.GameStatusReply.Builder> internal__static_MessageStruct_GameStatusReply__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_FindPassword__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.FindPassword, global::MessageStruct.FindPassword.Builder> internal__static_MessageStruct_FindPassword__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_UpdateUserInfo__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.UpdateUserInfo, global::MessageStruct.UpdateUserInfo.Builder> internal__static_MessageStruct_UpdateUserInfo__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_AdPictureItemReply__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.AdPictureItemReply, global::MessageStruct.AdPictureItemReply.Builder> internal__static_MessageStruct_AdPictureItemReply__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_AdPictureReq__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.AdPictureReq, global::MessageStruct.AdPictureReq.Builder> internal__static_MessageStruct_AdPictureReq__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_MessageStruct_AdPictureContentReply__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::MessageStruct.AdPictureContentReply, global::MessageStruct.AdPictureContentReply.Builder> internal__static_MessageStruct_AdPictureContentReply__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static Message() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cg1tZXNzYWdlLnByb3RvEg1NZXNzYWdlU3RydWN0IhoKBEVjaG8SEgoKdGlt", 
            "ZV9zdGFtcBgBIAEoCSIvCgpMb2dPbm9yT3V0Eg8KB2FjY291bnQYASACKAkS", 
            "EAoIcGFzc3dvcmQYAiACKAkiQAoMSW1hZ2VWZXJzaW9uEhYKDnNlcnZlcl92", 
            "ZXJzaW9uGAEgAigJEhgKEG1hbmRhdG9yeV91cGRhdGUYAiACKAgifQoLUmVw", 
            "bHlTdGF0dXMSDgoGc3RhdHVzGAEgAigNEisKBHVzZXIYAiABKAsyHS5NZXNz", 
            "YWdlU3RydWN0LkNoZXNzQm9hcmRVc2VyEjEKDHZlcnNpb25faW5mbxgDIAEo", 
            "CzIbLk1lc3NhZ2VTdHJ1Y3QuSW1hZ2VWZXJzaW9uIkUKCFJlZ2lzdGVyEhUK", 
            "DWVtYWlsX2FjY291bnQYASACKAkSEAoIcGFzc3dvcmQYAiACKAkSEAoIdXNl", 
            "cm5hbWUYAyABKAkiowEKDkNoZXNzQm9hcmRVc2VyEhkKEWNoZXNzX2JvYXJk", 
            "X2VtcHR5GAEgAigIEhEKCXVzZXJfbmFtZRgCIAEoCRIPCgdhY2NvdW50GAMg", 
            "ASgJEg0KBXNjb3JlGAQgASgFEhAKCGV4X2VtYWlsGAUgASgJEg0KBXBob25l", 
            "GAYgASgJEhIKCmhlYWRfaW1hZ2UYByABKAwSDgoGc3RhdHVzGAggASgNIjsK", 
            "EUNoZXNzQm9hcmRJbmZvUmVxEhYKDmNoZXNzX2JvYXJkX2lkGAEgAigFEg4K", 
            "Bm9wY29kZRgCIAEoBSLJAQoOQ2hlc3NCb2FyZEluZm8SCgoCaWQYASACKA0S", 
            "EgoKcGVvcGxlX251bRgCIAIoDRIwCglsZWZ0X3VzZXIYAyACKAsyHS5NZXNz", 
            "YWdlU3RydWN0LkNoZXNzQm9hcmRVc2VyEjEKCnJpZ2h0X3VzZXIYBCACKAsy", 
            "HS5NZXNzYWdlU3RydWN0LkNoZXNzQm9hcmRVc2VyEjIKC2JvdHRvbV91c2Vy", 
            "GAUgAigLMh0uTWVzc2FnZVN0cnVjdC5DaGVzc0JvYXJkVXNlciIzCgtIYWxs", 
            "SW5mb1JlcRIUCgxnYW1lX2hhbGxfaWQYASACKAUSDgoGb3Bjb2RlGAIgASgF", 
            "IpkBCghIYWxsSW5mbxIUCgxnYW1lX2hhbGxfaWQYASACKAUSFAoMdG90YWxf", 
            "cGVvcGxlGAIgAigNEhMKC2N1cnJfcGVvcGxlGAMgAigNEhgKEHRvdGFsX2No", 
            "ZXNzYm9hcmQYBCABKA0SMgoLY2hlc3NfYm9hcmQYBSADKAsyHS5NZXNzYWdl", 
            "U3RydWN0LkNoZXNzQm9hcmRJbmZvIiMKEUdhbWVIYWxsU3VtYXJ5UmVxEg4K", 
            "Bm9wY29kZRgBIAEoBSLAAQoOR2FtZUhhbGxTdW1hcnkSDwoHYWNjb3VudBgB", 
            "IAIoCRIQCgh1c2VybmFtZRgCIAIoCRINCgVzY29yZRgDIAIoBRIQCghoYWxs", 
            "X251bRgEIAIoDRIUCgxoZWFkX3BpY3R1cmUYBSACKAkSEwoLYWRfcGljdHVy", 
            "ZTEYBiACKAkSEwoLYWRfcGljdHVyZTIYByABKAkSKgoJaGFsbF9pbmZvGAgg", 
            "AygLMhcuTWVzc2FnZVN0cnVjdC5IYWxsSW5mbyJLCgtSZXF1ZXN0UGxheRIU", 
            "CgxnYW1lX2hhbGxfaWQYASACKAUSFgoOY2hlc3NfYm9hcmRfaWQYAiACKAUS", 
            "DgoGbG9jYXRlGAMgAigFInUKEFJlcXVlc3RQbGF5UmVwbHkSDgoGc3RhdHVz", 
            "GAEgAigFEh4KFmZpcnN0X2NvbWVfdXNlcl9sb2NhdGUYAiACKA0SMQoKY2hl", 
            "c3NCb2FyZBgDIAEoCzIdLk1lc3NhZ2VTdHJ1Y3QuQ2hlc3NCb2FyZEluZm8i", 
            "3AEKCU1vdmVDaGVzcxIWCg5zcmNfY2hlc3NfdHlwZRgBIAIoBRIXCg9zcmNf", 
            "dXNlcl9sb2NhdGUYAiACKAUSEwoLZnJvbV9wb2ludFgYAyACKAUSEwoLZnJv", 
            "bV9wb2ludFkYBCACKAUSEgoKZGVzX3BvaW50WBgFIAIoBRISCgpkZXNfcG9p", 
            "bnRZGAYgAigFEhEKCWlzX3dpbm5lchgHIAIoCBIdChVlYXRfdGFyZ2V0X2No", 
            "ZXNzX3R5cGUYCCABKAUSGgoSdGFyZ2V0X3VzZXJfbG9jYXRlGAkgASgNImgK", 
            "Ck1vdmVBY3Rpb24SFwoPc3JjX3VzZXJfbG9jYXRlGAEgAigNEisKCW1vdmVj", 
            "aGVzcxgCIAIoCzIYLk1lc3NhZ2VTdHJ1Y3QuTW92ZUNoZXNzEhQKDHRva2Vu", 
            "X2xvY2F0ZRgDIAIoDSI6CgtVc2VyTWVzc2FnZRIXCg9zcmNfdXNlcl9sb2Nh", 
            "dGUYASACKA0SEgoKbXNnQ29udGVudBgCIAIoCSIjCg1TeXN0ZW1NZXNzYWdl", 
            "EhIKCm1zZ0NvbnRlbnQYASACKAkiZgoKUmVjb25jaWxlZBIWCg5hcHBseV9v", 
            "cl9yZXBseRgBIAIoDRIXCg9zcmNfdXNlcl9sb2NhdGUYAiACKA0SFwoPdGFy", 
            "X3VzZXJfbG9jYXRlGAMgAigNEg4KBnN0YXR1cxgEIAEoCSIuCgZHaXZlVXAS", 
            "FwoPc3JjX3VzZXJfbG9jYXRlGAEgAigNEgsKA29wdBgCIAEoCSJfCgRVbmRv", 
            "EhUKDXJlcF9vcl9yZXNwb24YASACKA0SFwoPc3JjX3VzZXJfbG9jYXRlGAIg", 
            "AigNEhcKD3Rhcl91c2VyX2xvY2F0ZRgDIAIoDRIOCgZzdGF0dXMYBCABKAgi", 
            "ZQoMR2FtZVJlYWR5UmVxEhcKD3NyY191c2VyX2xvY2F0ZRgBIAIoDRIOCgZv", 
            "cGNvZGUYAiABKA0SEgoKdG90YWxfdGltZRgDIAEoDRIYChBzaW5nbGVfc3Rl", 
            "cF90aW1lGAQgASgNIqYBCg9HYW1lU3RhdHVzUmVwbHkSGAoQbGVmdF91c2Vy", 
            "X3N0YXR1cxgBIAIoCBIZChFyaWdodF91c2VyX3N0YXR1cxgCIAIoCBIaChJi", 
            "b3R0b21fdXNlcl9zdGF0dXMYAyACKAgSFAoMdG9rZW5fbG9jYXRlGAQgAigN", 
            "EhIKCnRvdGFsX3RpbWUYBSACKA0SGAoQc2luZ2xlX3N0ZXBfdGltZRgGIAIo", 
            "DSIqCgxGaW5kUGFzc3dvcmQSDQoFZW1haWwYASACKAkSCwoDb3B0GAIgASgJ", 
            "InsKDlVwZGF0ZVVzZXJJbmZvEhEKCXVzZXJfbmFtZRgBIAIoCRIPCgdhY2Nv", 
            "dW50GAIgAigJEhAKCHBhc3N3b3JkGAMgAigJEhAKCGV4X2VtYWlsGAQgASgJ", 
            "Eg0KBXBob25lGAUgASgJEhIKCmhlYWRfaW1hZ2UYBiABKAwimAEKEkFkUGlj", 
            "dHVyZUl0ZW1SZXBseRIQCghpbWFnZV9pZBgBIAIoDRIPCgdleGlzdGVkGAIg", 
            "AigIEhIKCmltYWdlX3R5cGUYAyABKAkSEgoKaW1hZ2VfbmFtZRgEIAEoCRIW", 
            "Cg5pbWFnZV9oYXNoY29kZRgFIAEoCRILCgN1cmwYBiABKAkSEgoKaW1hZ2Vf", 
            "c2l6ZRgHIAEoDSJECgxBZFBpY3R1cmVSZXESEAoIaW1hZ2VfaWQYASACKA0S", 
            "EAoIcmVxX3R5cGUYAiACKA0SEAoIbGFzdF9vbmUYAyABKAgiNwoVQWRQaWN0", 
            "dXJlQ29udGVudFJlcGx5Eg0KBWVuZGVkGAEgAigIEg8KB2NvbnRlbnQYAiAB", 
          "KAw="));
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_MessageStruct_Echo__Descriptor = Descriptor.MessageTypes[0];
        internal__static_MessageStruct_Echo__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.Echo, global::MessageStruct.Echo.Builder>(internal__static_MessageStruct_Echo__Descriptor,
                new string[] { "TimeStamp", });
        internal__static_MessageStruct_LogOnorOut__Descriptor = Descriptor.MessageTypes[1];
        internal__static_MessageStruct_LogOnorOut__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.LogOnorOut, global::MessageStruct.LogOnorOut.Builder>(internal__static_MessageStruct_LogOnorOut__Descriptor,
                new string[] { "Account", "Password", });
        internal__static_MessageStruct_ImageVersion__Descriptor = Descriptor.MessageTypes[2];
        internal__static_MessageStruct_ImageVersion__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.ImageVersion, global::MessageStruct.ImageVersion.Builder>(internal__static_MessageStruct_ImageVersion__Descriptor,
                new string[] { "ServerVersion", "MandatoryUpdate", });
        internal__static_MessageStruct_ReplyStatus__Descriptor = Descriptor.MessageTypes[3];
        internal__static_MessageStruct_ReplyStatus__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.ReplyStatus, global::MessageStruct.ReplyStatus.Builder>(internal__static_MessageStruct_ReplyStatus__Descriptor,
                new string[] { "Status", "User", "VersionInfo", });
        internal__static_MessageStruct_Register__Descriptor = Descriptor.MessageTypes[4];
        internal__static_MessageStruct_Register__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.Register, global::MessageStruct.Register.Builder>(internal__static_MessageStruct_Register__Descriptor,
                new string[] { "EmailAccount", "Password", "Username", });
        internal__static_MessageStruct_ChessBoardUser__Descriptor = Descriptor.MessageTypes[5];
        internal__static_MessageStruct_ChessBoardUser__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.ChessBoardUser, global::MessageStruct.ChessBoardUser.Builder>(internal__static_MessageStruct_ChessBoardUser__Descriptor,
                new string[] { "ChessBoardEmpty", "UserName", "Account", "Score", "ExEmail", "Phone", "HeadImage", "Status", });
        internal__static_MessageStruct_ChessBoardInfoReq__Descriptor = Descriptor.MessageTypes[6];
        internal__static_MessageStruct_ChessBoardInfoReq__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.ChessBoardInfoReq, global::MessageStruct.ChessBoardInfoReq.Builder>(internal__static_MessageStruct_ChessBoardInfoReq__Descriptor,
                new string[] { "ChessBoardId", "Opcode", });
        internal__static_MessageStruct_ChessBoardInfo__Descriptor = Descriptor.MessageTypes[7];
        internal__static_MessageStruct_ChessBoardInfo__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.ChessBoardInfo, global::MessageStruct.ChessBoardInfo.Builder>(internal__static_MessageStruct_ChessBoardInfo__Descriptor,
                new string[] { "Id", "PeopleNum", "LeftUser", "RightUser", "BottomUser", });
        internal__static_MessageStruct_HallInfoReq__Descriptor = Descriptor.MessageTypes[8];
        internal__static_MessageStruct_HallInfoReq__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.HallInfoReq, global::MessageStruct.HallInfoReq.Builder>(internal__static_MessageStruct_HallInfoReq__Descriptor,
                new string[] { "GameHallId", "Opcode", });
        internal__static_MessageStruct_HallInfo__Descriptor = Descriptor.MessageTypes[9];
        internal__static_MessageStruct_HallInfo__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.HallInfo, global::MessageStruct.HallInfo.Builder>(internal__static_MessageStruct_HallInfo__Descriptor,
                new string[] { "GameHallId", "TotalPeople", "CurrPeople", "TotalChessboard", "ChessBoard", });
        internal__static_MessageStruct_GameHallSumaryReq__Descriptor = Descriptor.MessageTypes[10];
        internal__static_MessageStruct_GameHallSumaryReq__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.GameHallSumaryReq, global::MessageStruct.GameHallSumaryReq.Builder>(internal__static_MessageStruct_GameHallSumaryReq__Descriptor,
                new string[] { "Opcode", });
        internal__static_MessageStruct_GameHallSumary__Descriptor = Descriptor.MessageTypes[11];
        internal__static_MessageStruct_GameHallSumary__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.GameHallSumary, global::MessageStruct.GameHallSumary.Builder>(internal__static_MessageStruct_GameHallSumary__Descriptor,
                new string[] { "Account", "Username", "Score", "HallNum", "HeadPicture", "AdPicture1", "AdPicture2", "HallInfo", });
        internal__static_MessageStruct_RequestPlay__Descriptor = Descriptor.MessageTypes[12];
        internal__static_MessageStruct_RequestPlay__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.RequestPlay, global::MessageStruct.RequestPlay.Builder>(internal__static_MessageStruct_RequestPlay__Descriptor,
                new string[] { "GameHallId", "ChessBoardId", "Locate", });
        internal__static_MessageStruct_RequestPlayReply__Descriptor = Descriptor.MessageTypes[13];
        internal__static_MessageStruct_RequestPlayReply__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.RequestPlayReply, global::MessageStruct.RequestPlayReply.Builder>(internal__static_MessageStruct_RequestPlayReply__Descriptor,
                new string[] { "Status", "FirstComeUserLocate", "ChessBoard", });
        internal__static_MessageStruct_MoveChess__Descriptor = Descriptor.MessageTypes[14];
        internal__static_MessageStruct_MoveChess__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.MoveChess, global::MessageStruct.MoveChess.Builder>(internal__static_MessageStruct_MoveChess__Descriptor,
                new string[] { "SrcChessType", "SrcUserLocate", "FromPointX", "FromPointY", "DesPointX", "DesPointY", "IsWinner", "EatTargetChessType", "TargetUserLocate", });
        internal__static_MessageStruct_MoveAction__Descriptor = Descriptor.MessageTypes[15];
        internal__static_MessageStruct_MoveAction__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.MoveAction, global::MessageStruct.MoveAction.Builder>(internal__static_MessageStruct_MoveAction__Descriptor,
                new string[] { "SrcUserLocate", "Movechess", "TokenLocate", });
        internal__static_MessageStruct_UserMessage__Descriptor = Descriptor.MessageTypes[16];
        internal__static_MessageStruct_UserMessage__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.UserMessage, global::MessageStruct.UserMessage.Builder>(internal__static_MessageStruct_UserMessage__Descriptor,
                new string[] { "SrcUserLocate", "MsgContent", });
        internal__static_MessageStruct_SystemMessage__Descriptor = Descriptor.MessageTypes[17];
        internal__static_MessageStruct_SystemMessage__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.SystemMessage, global::MessageStruct.SystemMessage.Builder>(internal__static_MessageStruct_SystemMessage__Descriptor,
                new string[] { "MsgContent", });
        internal__static_MessageStruct_Reconciled__Descriptor = Descriptor.MessageTypes[18];
        internal__static_MessageStruct_Reconciled__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.Reconciled, global::MessageStruct.Reconciled.Builder>(internal__static_MessageStruct_Reconciled__Descriptor,
                new string[] { "ApplyOrReply", "SrcUserLocate", "TarUserLocate", "Status", });
        internal__static_MessageStruct_GiveUp__Descriptor = Descriptor.MessageTypes[19];
        internal__static_MessageStruct_GiveUp__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.GiveUp, global::MessageStruct.GiveUp.Builder>(internal__static_MessageStruct_GiveUp__Descriptor,
                new string[] { "SrcUserLocate", "Opt", });
        internal__static_MessageStruct_Undo__Descriptor = Descriptor.MessageTypes[20];
        internal__static_MessageStruct_Undo__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.Undo, global::MessageStruct.Undo.Builder>(internal__static_MessageStruct_Undo__Descriptor,
                new string[] { "RepOrRespon", "SrcUserLocate", "TarUserLocate", "Status", });
        internal__static_MessageStruct_GameReadyReq__Descriptor = Descriptor.MessageTypes[21];
        internal__static_MessageStruct_GameReadyReq__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.GameReadyReq, global::MessageStruct.GameReadyReq.Builder>(internal__static_MessageStruct_GameReadyReq__Descriptor,
                new string[] { "SrcUserLocate", "Opcode", "TotalTime", "SingleStepTime", });
        internal__static_MessageStruct_GameStatusReply__Descriptor = Descriptor.MessageTypes[22];
        internal__static_MessageStruct_GameStatusReply__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.GameStatusReply, global::MessageStruct.GameStatusReply.Builder>(internal__static_MessageStruct_GameStatusReply__Descriptor,
                new string[] { "LeftUserStatus", "RightUserStatus", "BottomUserStatus", "TokenLocate", "TotalTime", "SingleStepTime", });
        internal__static_MessageStruct_FindPassword__Descriptor = Descriptor.MessageTypes[23];
        internal__static_MessageStruct_FindPassword__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.FindPassword, global::MessageStruct.FindPassword.Builder>(internal__static_MessageStruct_FindPassword__Descriptor,
                new string[] { "Email", "Opt", });
        internal__static_MessageStruct_UpdateUserInfo__Descriptor = Descriptor.MessageTypes[24];
        internal__static_MessageStruct_UpdateUserInfo__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.UpdateUserInfo, global::MessageStruct.UpdateUserInfo.Builder>(internal__static_MessageStruct_UpdateUserInfo__Descriptor,
                new string[] { "UserName", "Account", "Password", "ExEmail", "Phone", "HeadImage", });
        internal__static_MessageStruct_AdPictureItemReply__Descriptor = Descriptor.MessageTypes[25];
        internal__static_MessageStruct_AdPictureItemReply__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.AdPictureItemReply, global::MessageStruct.AdPictureItemReply.Builder>(internal__static_MessageStruct_AdPictureItemReply__Descriptor,
                new string[] { "ImageId", "Existed", "ImageType", "ImageName", "ImageHashcode", "Url", "ImageSize", });
        internal__static_MessageStruct_AdPictureReq__Descriptor = Descriptor.MessageTypes[26];
        internal__static_MessageStruct_AdPictureReq__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.AdPictureReq, global::MessageStruct.AdPictureReq.Builder>(internal__static_MessageStruct_AdPictureReq__Descriptor,
                new string[] { "ImageId", "ReqType", "LastOne", });
        internal__static_MessageStruct_AdPictureContentReply__Descriptor = Descriptor.MessageTypes[27];
        internal__static_MessageStruct_AdPictureContentReply__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::MessageStruct.AdPictureContentReply, global::MessageStruct.AdPictureContentReply.Builder>(internal__static_MessageStruct_AdPictureContentReply__Descriptor,
                new string[] { "Ended", "Content", });
        return null;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          }, assigner);
    }
    #endregion
    
  }
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Echo : pb::GeneratedMessage<Echo, Echo.Builder> {
    private Echo() { }
    private static readonly Echo defaultInstance = new Echo().MakeReadOnly();
    private static readonly string[] _echoFieldNames = new string[] { "time_stamp" };
    private static readonly uint[] _echoFieldTags = new uint[] { 10 };
    public static Echo DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Echo DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Echo ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_Echo__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Echo, Echo.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_Echo__FieldAccessorTable; }
    }
    
    public const int TimeStampFieldNumber = 1;
    private bool hasTimeStamp;
    private string timeStamp_ = "";
    public bool HasTimeStamp {
      get { return hasTimeStamp; }
    }
    public string TimeStamp {
      get { return timeStamp_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _echoFieldNames;
      if (hasTimeStamp) {
        output.WriteString(1, field_names[0], TimeStamp);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasTimeStamp) {
        size += pb::CodedOutputStream.ComputeStringSize(1, TimeStamp);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static Echo ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Echo ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Echo ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Echo ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Echo ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Echo ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Echo ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Echo ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Echo ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Echo ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Echo MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Echo prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Echo, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Echo cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Echo result;
      
      private Echo PrepareBuilder() {
        if (resultIsReadOnly) {
          Echo original = result;
          result = new Echo();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Echo MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.Echo.Descriptor; }
      }
      
      public override Echo DefaultInstanceForType {
        get { return global::MessageStruct.Echo.DefaultInstance; }
      }
      
      public override Echo BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Echo) {
          return MergeFrom((Echo) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Echo other) {
        if (other == global::MessageStruct.Echo.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasTimeStamp) {
          TimeStamp = other.TimeStamp;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_echoFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _echoFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasTimeStamp = input.ReadString(ref result.timeStamp_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasTimeStamp {
        get { return result.hasTimeStamp; }
      }
      public string TimeStamp {
        get { return result.TimeStamp; }
        set { SetTimeStamp(value); }
      }
      public Builder SetTimeStamp(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasTimeStamp = true;
        result.timeStamp_ = value;
        return this;
      }
      public Builder ClearTimeStamp() {
        PrepareBuilder();
        result.hasTimeStamp = false;
        result.timeStamp_ = "";
        return this;
      }
    }
    static Echo() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class LogOnorOut : pb::GeneratedMessage<LogOnorOut, LogOnorOut.Builder> {
    private LogOnorOut() { }
    private static readonly LogOnorOut defaultInstance = new LogOnorOut().MakeReadOnly();
    private static readonly string[] _logOnorOutFieldNames = new string[] { "account", "password" };
    private static readonly uint[] _logOnorOutFieldTags = new uint[] { 10, 18 };
    public static LogOnorOut DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override LogOnorOut DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override LogOnorOut ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_LogOnorOut__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<LogOnorOut, LogOnorOut.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_LogOnorOut__FieldAccessorTable; }
    }
    
    public const int AccountFieldNumber = 1;
    private bool hasAccount;
    private string account_ = "";
    public bool HasAccount {
      get { return hasAccount; }
    }
    public string Account {
      get { return account_; }
    }
    
    public const int PasswordFieldNumber = 2;
    private bool hasPassword;
    private string password_ = "";
    public bool HasPassword {
      get { return hasPassword; }
    }
    public string Password {
      get { return password_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasAccount) return false;
        if (!hasPassword) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _logOnorOutFieldNames;
      if (hasAccount) {
        output.WriteString(1, field_names[0], Account);
      }
      if (hasPassword) {
        output.WriteString(2, field_names[1], Password);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasAccount) {
        size += pb::CodedOutputStream.ComputeStringSize(1, Account);
      }
      if (hasPassword) {
        size += pb::CodedOutputStream.ComputeStringSize(2, Password);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static LogOnorOut ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static LogOnorOut ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static LogOnorOut ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static LogOnorOut ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static LogOnorOut ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static LogOnorOut ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static LogOnorOut ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static LogOnorOut ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static LogOnorOut ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static LogOnorOut ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private LogOnorOut MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(LogOnorOut prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<LogOnorOut, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(LogOnorOut cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private LogOnorOut result;
      
      private LogOnorOut PrepareBuilder() {
        if (resultIsReadOnly) {
          LogOnorOut original = result;
          result = new LogOnorOut();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override LogOnorOut MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.LogOnorOut.Descriptor; }
      }
      
      public override LogOnorOut DefaultInstanceForType {
        get { return global::MessageStruct.LogOnorOut.DefaultInstance; }
      }
      
      public override LogOnorOut BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is LogOnorOut) {
          return MergeFrom((LogOnorOut) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(LogOnorOut other) {
        if (other == global::MessageStruct.LogOnorOut.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasAccount) {
          Account = other.Account;
        }
        if (other.HasPassword) {
          Password = other.Password;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_logOnorOutFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _logOnorOutFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasAccount = input.ReadString(ref result.account_);
              break;
            }
            case 18: {
              result.hasPassword = input.ReadString(ref result.password_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasAccount {
        get { return result.hasAccount; }
      }
      public string Account {
        get { return result.Account; }
        set { SetAccount(value); }
      }
      public Builder SetAccount(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasAccount = true;
        result.account_ = value;
        return this;
      }
      public Builder ClearAccount() {
        PrepareBuilder();
        result.hasAccount = false;
        result.account_ = "";
        return this;
      }
      
      public bool HasPassword {
        get { return result.hasPassword; }
      }
      public string Password {
        get { return result.Password; }
        set { SetPassword(value); }
      }
      public Builder SetPassword(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPassword = true;
        result.password_ = value;
        return this;
      }
      public Builder ClearPassword() {
        PrepareBuilder();
        result.hasPassword = false;
        result.password_ = "";
        return this;
      }
    }
    static LogOnorOut() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class ImageVersion : pb::GeneratedMessage<ImageVersion, ImageVersion.Builder> {
    private ImageVersion() { }
    private static readonly ImageVersion defaultInstance = new ImageVersion().MakeReadOnly();
    private static readonly string[] _imageVersionFieldNames = new string[] { "mandatory_update", "server_version" };
    private static readonly uint[] _imageVersionFieldTags = new uint[] { 16, 10 };
    public static ImageVersion DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ImageVersion DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ImageVersion ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_ImageVersion__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ImageVersion, ImageVersion.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_ImageVersion__FieldAccessorTable; }
    }
    
    public const int ServerVersionFieldNumber = 1;
    private bool hasServerVersion;
    private string serverVersion_ = "";
    public bool HasServerVersion {
      get { return hasServerVersion; }
    }
    public string ServerVersion {
      get { return serverVersion_; }
    }
    
    public const int MandatoryUpdateFieldNumber = 2;
    private bool hasMandatoryUpdate;
    private bool mandatoryUpdate_;
    public bool HasMandatoryUpdate {
      get { return hasMandatoryUpdate; }
    }
    public bool MandatoryUpdate {
      get { return mandatoryUpdate_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasServerVersion) return false;
        if (!hasMandatoryUpdate) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _imageVersionFieldNames;
      if (hasServerVersion) {
        output.WriteString(1, field_names[1], ServerVersion);
      }
      if (hasMandatoryUpdate) {
        output.WriteBool(2, field_names[0], MandatoryUpdate);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasServerVersion) {
        size += pb::CodedOutputStream.ComputeStringSize(1, ServerVersion);
      }
      if (hasMandatoryUpdate) {
        size += pb::CodedOutputStream.ComputeBoolSize(2, MandatoryUpdate);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static ImageVersion ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ImageVersion ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ImageVersion ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ImageVersion ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ImageVersion ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ImageVersion ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ImageVersion ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ImageVersion ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ImageVersion ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ImageVersion ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ImageVersion MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ImageVersion prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<ImageVersion, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ImageVersion cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ImageVersion result;
      
      private ImageVersion PrepareBuilder() {
        if (resultIsReadOnly) {
          ImageVersion original = result;
          result = new ImageVersion();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ImageVersion MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.ImageVersion.Descriptor; }
      }
      
      public override ImageVersion DefaultInstanceForType {
        get { return global::MessageStruct.ImageVersion.DefaultInstance; }
      }
      
      public override ImageVersion BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ImageVersion) {
          return MergeFrom((ImageVersion) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ImageVersion other) {
        if (other == global::MessageStruct.ImageVersion.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasServerVersion) {
          ServerVersion = other.ServerVersion;
        }
        if (other.HasMandatoryUpdate) {
          MandatoryUpdate = other.MandatoryUpdate;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_imageVersionFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _imageVersionFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasServerVersion = input.ReadString(ref result.serverVersion_);
              break;
            }
            case 16: {
              result.hasMandatoryUpdate = input.ReadBool(ref result.mandatoryUpdate_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasServerVersion {
        get { return result.hasServerVersion; }
      }
      public string ServerVersion {
        get { return result.ServerVersion; }
        set { SetServerVersion(value); }
      }
      public Builder SetServerVersion(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasServerVersion = true;
        result.serverVersion_ = value;
        return this;
      }
      public Builder ClearServerVersion() {
        PrepareBuilder();
        result.hasServerVersion = false;
        result.serverVersion_ = "";
        return this;
      }
      
      public bool HasMandatoryUpdate {
        get { return result.hasMandatoryUpdate; }
      }
      public bool MandatoryUpdate {
        get { return result.MandatoryUpdate; }
        set { SetMandatoryUpdate(value); }
      }
      public Builder SetMandatoryUpdate(bool value) {
        PrepareBuilder();
        result.hasMandatoryUpdate = true;
        result.mandatoryUpdate_ = value;
        return this;
      }
      public Builder ClearMandatoryUpdate() {
        PrepareBuilder();
        result.hasMandatoryUpdate = false;
        result.mandatoryUpdate_ = false;
        return this;
      }
    }
    static ImageVersion() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class ReplyStatus : pb::GeneratedMessage<ReplyStatus, ReplyStatus.Builder> {
    private ReplyStatus() { }
    private static readonly ReplyStatus defaultInstance = new ReplyStatus().MakeReadOnly();
    private static readonly string[] _replyStatusFieldNames = new string[] { "status", "user", "version_info" };
    private static readonly uint[] _replyStatusFieldTags = new uint[] { 8, 18, 26 };
    public static ReplyStatus DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ReplyStatus DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ReplyStatus ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_ReplyStatus__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ReplyStatus, ReplyStatus.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_ReplyStatus__FieldAccessorTable; }
    }
    
    public const int StatusFieldNumber = 1;
    private bool hasStatus;
    private uint status_;
    public bool HasStatus {
      get { return hasStatus; }
    }
    [global::System.CLSCompliant(false)]
    public uint Status {
      get { return status_; }
    }
    
    public const int UserFieldNumber = 2;
    private bool hasUser;
    private global::MessageStruct.ChessBoardUser user_;
    public bool HasUser {
      get { return hasUser; }
    }
    public global::MessageStruct.ChessBoardUser User {
      get { return user_ ?? global::MessageStruct.ChessBoardUser.DefaultInstance; }
    }
    
    public const int VersionInfoFieldNumber = 3;
    private bool hasVersionInfo;
    private global::MessageStruct.ImageVersion versionInfo_;
    public bool HasVersionInfo {
      get { return hasVersionInfo; }
    }
    public global::MessageStruct.ImageVersion VersionInfo {
      get { return versionInfo_ ?? global::MessageStruct.ImageVersion.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasStatus) return false;
        if (HasUser) {
          if (!User.IsInitialized) return false;
        }
        if (HasVersionInfo) {
          if (!VersionInfo.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _replyStatusFieldNames;
      if (hasStatus) {
        output.WriteUInt32(1, field_names[0], Status);
      }
      if (hasUser) {
        output.WriteMessage(2, field_names[1], User);
      }
      if (hasVersionInfo) {
        output.WriteMessage(3, field_names[2], VersionInfo);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasStatus) {
        size += pb::CodedOutputStream.ComputeUInt32Size(1, Status);
      }
      if (hasUser) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, User);
      }
      if (hasVersionInfo) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, VersionInfo);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static ReplyStatus ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ReplyStatus ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ReplyStatus ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ReplyStatus ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ReplyStatus ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ReplyStatus ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ReplyStatus ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ReplyStatus ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ReplyStatus ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ReplyStatus ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ReplyStatus MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ReplyStatus prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<ReplyStatus, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ReplyStatus cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ReplyStatus result;
      
      private ReplyStatus PrepareBuilder() {
        if (resultIsReadOnly) {
          ReplyStatus original = result;
          result = new ReplyStatus();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ReplyStatus MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.ReplyStatus.Descriptor; }
      }
      
      public override ReplyStatus DefaultInstanceForType {
        get { return global::MessageStruct.ReplyStatus.DefaultInstance; }
      }
      
      public override ReplyStatus BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ReplyStatus) {
          return MergeFrom((ReplyStatus) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ReplyStatus other) {
        if (other == global::MessageStruct.ReplyStatus.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasStatus) {
          Status = other.Status;
        }
        if (other.HasUser) {
          MergeUser(other.User);
        }
        if (other.HasVersionInfo) {
          MergeVersionInfo(other.VersionInfo);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_replyStatusFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _replyStatusFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasStatus = input.ReadUInt32(ref result.status_);
              break;
            }
            case 18: {
              global::MessageStruct.ChessBoardUser.Builder subBuilder = global::MessageStruct.ChessBoardUser.CreateBuilder();
              if (result.hasUser) {
                subBuilder.MergeFrom(User);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              User = subBuilder.BuildPartial();
              break;
            }
            case 26: {
              global::MessageStruct.ImageVersion.Builder subBuilder = global::MessageStruct.ImageVersion.CreateBuilder();
              if (result.hasVersionInfo) {
                subBuilder.MergeFrom(VersionInfo);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              VersionInfo = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasStatus {
        get { return result.hasStatus; }
      }
      [global::System.CLSCompliant(false)]
      public uint Status {
        get { return result.Status; }
        set { SetStatus(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetStatus(uint value) {
        PrepareBuilder();
        result.hasStatus = true;
        result.status_ = value;
        return this;
      }
      public Builder ClearStatus() {
        PrepareBuilder();
        result.hasStatus = false;
        result.status_ = 0;
        return this;
      }
      
      public bool HasUser {
       get { return result.hasUser; }
      }
      public global::MessageStruct.ChessBoardUser User {
        get { return result.User; }
        set { SetUser(value); }
      }
      public Builder SetUser(global::MessageStruct.ChessBoardUser value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasUser = true;
        result.user_ = value;
        return this;
      }
      public Builder SetUser(global::MessageStruct.ChessBoardUser.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasUser = true;
        result.user_ = builderForValue.Build();
        return this;
      }
      public Builder MergeUser(global::MessageStruct.ChessBoardUser value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasUser &&
            result.user_ != global::MessageStruct.ChessBoardUser.DefaultInstance) {
            result.user_ = global::MessageStruct.ChessBoardUser.CreateBuilder(result.user_).MergeFrom(value).BuildPartial();
        } else {
          result.user_ = value;
        }
        result.hasUser = true;
        return this;
      }
      public Builder ClearUser() {
        PrepareBuilder();
        result.hasUser = false;
        result.user_ = null;
        return this;
      }
      
      public bool HasVersionInfo {
       get { return result.hasVersionInfo; }
      }
      public global::MessageStruct.ImageVersion VersionInfo {
        get { return result.VersionInfo; }
        set { SetVersionInfo(value); }
      }
      public Builder SetVersionInfo(global::MessageStruct.ImageVersion value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasVersionInfo = true;
        result.versionInfo_ = value;
        return this;
      }
      public Builder SetVersionInfo(global::MessageStruct.ImageVersion.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasVersionInfo = true;
        result.versionInfo_ = builderForValue.Build();
        return this;
      }
      public Builder MergeVersionInfo(global::MessageStruct.ImageVersion value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasVersionInfo &&
            result.versionInfo_ != global::MessageStruct.ImageVersion.DefaultInstance) {
            result.versionInfo_ = global::MessageStruct.ImageVersion.CreateBuilder(result.versionInfo_).MergeFrom(value).BuildPartial();
        } else {
          result.versionInfo_ = value;
        }
        result.hasVersionInfo = true;
        return this;
      }
      public Builder ClearVersionInfo() {
        PrepareBuilder();
        result.hasVersionInfo = false;
        result.versionInfo_ = null;
        return this;
      }
    }
    static ReplyStatus() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Register : pb::GeneratedMessage<Register, Register.Builder> {
    private Register() { }
    private static readonly Register defaultInstance = new Register().MakeReadOnly();
    private static readonly string[] _registerFieldNames = new string[] { "email_account", "password", "username" };
    private static readonly uint[] _registerFieldTags = new uint[] { 10, 18, 26 };
    public static Register DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Register DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Register ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_Register__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Register, Register.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_Register__FieldAccessorTable; }
    }
    
    public const int EmailAccountFieldNumber = 1;
    private bool hasEmailAccount;
    private string emailAccount_ = "";
    public bool HasEmailAccount {
      get { return hasEmailAccount; }
    }
    public string EmailAccount {
      get { return emailAccount_; }
    }
    
    public const int PasswordFieldNumber = 2;
    private bool hasPassword;
    private string password_ = "";
    public bool HasPassword {
      get { return hasPassword; }
    }
    public string Password {
      get { return password_; }
    }
    
    public const int UsernameFieldNumber = 3;
    private bool hasUsername;
    private string username_ = "";
    public bool HasUsername {
      get { return hasUsername; }
    }
    public string Username {
      get { return username_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasEmailAccount) return false;
        if (!hasPassword) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _registerFieldNames;
      if (hasEmailAccount) {
        output.WriteString(1, field_names[0], EmailAccount);
      }
      if (hasPassword) {
        output.WriteString(2, field_names[1], Password);
      }
      if (hasUsername) {
        output.WriteString(3, field_names[2], Username);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasEmailAccount) {
        size += pb::CodedOutputStream.ComputeStringSize(1, EmailAccount);
      }
      if (hasPassword) {
        size += pb::CodedOutputStream.ComputeStringSize(2, Password);
      }
      if (hasUsername) {
        size += pb::CodedOutputStream.ComputeStringSize(3, Username);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static Register ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Register ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Register ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Register ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Register ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Register ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Register ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Register ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Register ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Register ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Register MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Register prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Register, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Register cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Register result;
      
      private Register PrepareBuilder() {
        if (resultIsReadOnly) {
          Register original = result;
          result = new Register();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Register MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.Register.Descriptor; }
      }
      
      public override Register DefaultInstanceForType {
        get { return global::MessageStruct.Register.DefaultInstance; }
      }
      
      public override Register BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Register) {
          return MergeFrom((Register) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Register other) {
        if (other == global::MessageStruct.Register.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasEmailAccount) {
          EmailAccount = other.EmailAccount;
        }
        if (other.HasPassword) {
          Password = other.Password;
        }
        if (other.HasUsername) {
          Username = other.Username;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_registerFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _registerFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasEmailAccount = input.ReadString(ref result.emailAccount_);
              break;
            }
            case 18: {
              result.hasPassword = input.ReadString(ref result.password_);
              break;
            }
            case 26: {
              result.hasUsername = input.ReadString(ref result.username_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasEmailAccount {
        get { return result.hasEmailAccount; }
      }
      public string EmailAccount {
        get { return result.EmailAccount; }
        set { SetEmailAccount(value); }
      }
      public Builder SetEmailAccount(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasEmailAccount = true;
        result.emailAccount_ = value;
        return this;
      }
      public Builder ClearEmailAccount() {
        PrepareBuilder();
        result.hasEmailAccount = false;
        result.emailAccount_ = "";
        return this;
      }
      
      public bool HasPassword {
        get { return result.hasPassword; }
      }
      public string Password {
        get { return result.Password; }
        set { SetPassword(value); }
      }
      public Builder SetPassword(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPassword = true;
        result.password_ = value;
        return this;
      }
      public Builder ClearPassword() {
        PrepareBuilder();
        result.hasPassword = false;
        result.password_ = "";
        return this;
      }
      
      public bool HasUsername {
        get { return result.hasUsername; }
      }
      public string Username {
        get { return result.Username; }
        set { SetUsername(value); }
      }
      public Builder SetUsername(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasUsername = true;
        result.username_ = value;
        return this;
      }
      public Builder ClearUsername() {
        PrepareBuilder();
        result.hasUsername = false;
        result.username_ = "";
        return this;
      }
    }
    static Register() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class ChessBoardUser : pb::GeneratedMessage<ChessBoardUser, ChessBoardUser.Builder> {
    private ChessBoardUser() { }
    private static readonly ChessBoardUser defaultInstance = new ChessBoardUser().MakeReadOnly();
    private static readonly string[] _chessBoardUserFieldNames = new string[] { "account", "chess_board_empty", "ex_email", "head_image", "phone", "score", "status", "user_name" };
    private static readonly uint[] _chessBoardUserFieldTags = new uint[] { 26, 8, 42, 58, 50, 32, 64, 18 };
    public static ChessBoardUser DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ChessBoardUser DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ChessBoardUser ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_ChessBoardUser__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ChessBoardUser, ChessBoardUser.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_ChessBoardUser__FieldAccessorTable; }
    }
    
    public const int ChessBoardEmptyFieldNumber = 1;
    private bool hasChessBoardEmpty;
    private bool chessBoardEmpty_;
    public bool HasChessBoardEmpty {
      get { return hasChessBoardEmpty; }
    }
    public bool ChessBoardEmpty {
      get { return chessBoardEmpty_; }
    }
    
    public const int UserNameFieldNumber = 2;
    private bool hasUserName;
    private string userName_ = "";
    public bool HasUserName {
      get { return hasUserName; }
    }
    public string UserName {
      get { return userName_; }
    }
    
    public const int AccountFieldNumber = 3;
    private bool hasAccount;
    private string account_ = "";
    public bool HasAccount {
      get { return hasAccount; }
    }
    public string Account {
      get { return account_; }
    }
    
    public const int ScoreFieldNumber = 4;
    private bool hasScore;
    private int score_;
    public bool HasScore {
      get { return hasScore; }
    }
    public int Score {
      get { return score_; }
    }
    
    public const int ExEmailFieldNumber = 5;
    private bool hasExEmail;
    private string exEmail_ = "";
    public bool HasExEmail {
      get { return hasExEmail; }
    }
    public string ExEmail {
      get { return exEmail_; }
    }
    
    public const int PhoneFieldNumber = 6;
    private bool hasPhone;
    private string phone_ = "";
    public bool HasPhone {
      get { return hasPhone; }
    }
    public string Phone {
      get { return phone_; }
    }
    
    public const int HeadImageFieldNumber = 7;
    private bool hasHeadImage;
    private pb::ByteString headImage_ = pb::ByteString.Empty;
    public bool HasHeadImage {
      get { return hasHeadImage; }
    }
    public pb::ByteString HeadImage {
      get { return headImage_; }
    }
    
    public const int StatusFieldNumber = 8;
    private bool hasStatus;
    private uint status_;
    public bool HasStatus {
      get { return hasStatus; }
    }
    [global::System.CLSCompliant(false)]
    public uint Status {
      get { return status_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasChessBoardEmpty) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _chessBoardUserFieldNames;
      if (hasChessBoardEmpty) {
        output.WriteBool(1, field_names[1], ChessBoardEmpty);
      }
      if (hasUserName) {
        output.WriteString(2, field_names[7], UserName);
      }
      if (hasAccount) {
        output.WriteString(3, field_names[0], Account);
      }
      if (hasScore) {
        output.WriteInt32(4, field_names[5], Score);
      }
      if (hasExEmail) {
        output.WriteString(5, field_names[2], ExEmail);
      }
      if (hasPhone) {
        output.WriteString(6, field_names[4], Phone);
      }
      if (hasHeadImage) {
        output.WriteBytes(7, field_names[3], HeadImage);
      }
      if (hasStatus) {
        output.WriteUInt32(8, field_names[6], Status);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasChessBoardEmpty) {
        size += pb::CodedOutputStream.ComputeBoolSize(1, ChessBoardEmpty);
      }
      if (hasUserName) {
        size += pb::CodedOutputStream.ComputeStringSize(2, UserName);
      }
      if (hasAccount) {
        size += pb::CodedOutputStream.ComputeStringSize(3, Account);
      }
      if (hasScore) {
        size += pb::CodedOutputStream.ComputeInt32Size(4, Score);
      }
      if (hasExEmail) {
        size += pb::CodedOutputStream.ComputeStringSize(5, ExEmail);
      }
      if (hasPhone) {
        size += pb::CodedOutputStream.ComputeStringSize(6, Phone);
      }
      if (hasHeadImage) {
        size += pb::CodedOutputStream.ComputeBytesSize(7, HeadImage);
      }
      if (hasStatus) {
        size += pb::CodedOutputStream.ComputeUInt32Size(8, Status);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static ChessBoardUser ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ChessBoardUser ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ChessBoardUser ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ChessBoardUser ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ChessBoardUser ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ChessBoardUser ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ChessBoardUser ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ChessBoardUser ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ChessBoardUser ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ChessBoardUser ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ChessBoardUser MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ChessBoardUser prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<ChessBoardUser, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ChessBoardUser cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ChessBoardUser result;
      
      private ChessBoardUser PrepareBuilder() {
        if (resultIsReadOnly) {
          ChessBoardUser original = result;
          result = new ChessBoardUser();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ChessBoardUser MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.ChessBoardUser.Descriptor; }
      }
      
      public override ChessBoardUser DefaultInstanceForType {
        get { return global::MessageStruct.ChessBoardUser.DefaultInstance; }
      }
      
      public override ChessBoardUser BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ChessBoardUser) {
          return MergeFrom((ChessBoardUser) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ChessBoardUser other) {
        if (other == global::MessageStruct.ChessBoardUser.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasChessBoardEmpty) {
          ChessBoardEmpty = other.ChessBoardEmpty;
        }
        if (other.HasUserName) {
          UserName = other.UserName;
        }
        if (other.HasAccount) {
          Account = other.Account;
        }
        if (other.HasScore) {
          Score = other.Score;
        }
        if (other.HasExEmail) {
          ExEmail = other.ExEmail;
        }
        if (other.HasPhone) {
          Phone = other.Phone;
        }
        if (other.HasHeadImage) {
          HeadImage = other.HeadImage;
        }
        if (other.HasStatus) {
          Status = other.Status;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_chessBoardUserFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _chessBoardUserFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasChessBoardEmpty = input.ReadBool(ref result.chessBoardEmpty_);
              break;
            }
            case 18: {
              result.hasUserName = input.ReadString(ref result.userName_);
              break;
            }
            case 26: {
              result.hasAccount = input.ReadString(ref result.account_);
              break;
            }
            case 32: {
              result.hasScore = input.ReadInt32(ref result.score_);
              break;
            }
            case 42: {
              result.hasExEmail = input.ReadString(ref result.exEmail_);
              break;
            }
            case 50: {
              result.hasPhone = input.ReadString(ref result.phone_);
              break;
            }
            case 58: {
              result.hasHeadImage = input.ReadBytes(ref result.headImage_);
              break;
            }
            case 64: {
              result.hasStatus = input.ReadUInt32(ref result.status_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasChessBoardEmpty {
        get { return result.hasChessBoardEmpty; }
      }
      public bool ChessBoardEmpty {
        get { return result.ChessBoardEmpty; }
        set { SetChessBoardEmpty(value); }
      }
      public Builder SetChessBoardEmpty(bool value) {
        PrepareBuilder();
        result.hasChessBoardEmpty = true;
        result.chessBoardEmpty_ = value;
        return this;
      }
      public Builder ClearChessBoardEmpty() {
        PrepareBuilder();
        result.hasChessBoardEmpty = false;
        result.chessBoardEmpty_ = false;
        return this;
      }
      
      public bool HasUserName {
        get { return result.hasUserName; }
      }
      public string UserName {
        get { return result.UserName; }
        set { SetUserName(value); }
      }
      public Builder SetUserName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasUserName = true;
        result.userName_ = value;
        return this;
      }
      public Builder ClearUserName() {
        PrepareBuilder();
        result.hasUserName = false;
        result.userName_ = "";
        return this;
      }
      
      public bool HasAccount {
        get { return result.hasAccount; }
      }
      public string Account {
        get { return result.Account; }
        set { SetAccount(value); }
      }
      public Builder SetAccount(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasAccount = true;
        result.account_ = value;
        return this;
      }
      public Builder ClearAccount() {
        PrepareBuilder();
        result.hasAccount = false;
        result.account_ = "";
        return this;
      }
      
      public bool HasScore {
        get { return result.hasScore; }
      }
      public int Score {
        get { return result.Score; }
        set { SetScore(value); }
      }
      public Builder SetScore(int value) {
        PrepareBuilder();
        result.hasScore = true;
        result.score_ = value;
        return this;
      }
      public Builder ClearScore() {
        PrepareBuilder();
        result.hasScore = false;
        result.score_ = 0;
        return this;
      }
      
      public bool HasExEmail {
        get { return result.hasExEmail; }
      }
      public string ExEmail {
        get { return result.ExEmail; }
        set { SetExEmail(value); }
      }
      public Builder SetExEmail(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasExEmail = true;
        result.exEmail_ = value;
        return this;
      }
      public Builder ClearExEmail() {
        PrepareBuilder();
        result.hasExEmail = false;
        result.exEmail_ = "";
        return this;
      }
      
      public bool HasPhone {
        get { return result.hasPhone; }
      }
      public string Phone {
        get { return result.Phone; }
        set { SetPhone(value); }
      }
      public Builder SetPhone(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPhone = true;
        result.phone_ = value;
        return this;
      }
      public Builder ClearPhone() {
        PrepareBuilder();
        result.hasPhone = false;
        result.phone_ = "";
        return this;
      }
      
      public bool HasHeadImage {
        get { return result.hasHeadImage; }
      }
      public pb::ByteString HeadImage {
        get { return result.HeadImage; }
        set { SetHeadImage(value); }
      }
      public Builder SetHeadImage(pb::ByteString value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasHeadImage = true;
        result.headImage_ = value;
        return this;
      }
      public Builder ClearHeadImage() {
        PrepareBuilder();
        result.hasHeadImage = false;
        result.headImage_ = pb::ByteString.Empty;
        return this;
      }
      
      public bool HasStatus {
        get { return result.hasStatus; }
      }
      [global::System.CLSCompliant(false)]
      public uint Status {
        get { return result.Status; }
        set { SetStatus(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetStatus(uint value) {
        PrepareBuilder();
        result.hasStatus = true;
        result.status_ = value;
        return this;
      }
      public Builder ClearStatus() {
        PrepareBuilder();
        result.hasStatus = false;
        result.status_ = 0;
        return this;
      }
    }
    static ChessBoardUser() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class ChessBoardInfoReq : pb::GeneratedMessage<ChessBoardInfoReq, ChessBoardInfoReq.Builder> {
    private ChessBoardInfoReq() { }
    private static readonly ChessBoardInfoReq defaultInstance = new ChessBoardInfoReq().MakeReadOnly();
    private static readonly string[] _chessBoardInfoReqFieldNames = new string[] { "chess_board_id", "opcode" };
    private static readonly uint[] _chessBoardInfoReqFieldTags = new uint[] { 8, 16 };
    public static ChessBoardInfoReq DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ChessBoardInfoReq DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ChessBoardInfoReq ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_ChessBoardInfoReq__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ChessBoardInfoReq, ChessBoardInfoReq.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_ChessBoardInfoReq__FieldAccessorTable; }
    }
    
    public const int ChessBoardIdFieldNumber = 1;
    private bool hasChessBoardId;
    private int chessBoardId_;
    public bool HasChessBoardId {
      get { return hasChessBoardId; }
    }
    public int ChessBoardId {
      get { return chessBoardId_; }
    }
    
    public const int OpcodeFieldNumber = 2;
    private bool hasOpcode;
    private int opcode_;
    public bool HasOpcode {
      get { return hasOpcode; }
    }
    public int Opcode {
      get { return opcode_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasChessBoardId) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _chessBoardInfoReqFieldNames;
      if (hasChessBoardId) {
        output.WriteInt32(1, field_names[0], ChessBoardId);
      }
      if (hasOpcode) {
        output.WriteInt32(2, field_names[1], Opcode);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasChessBoardId) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, ChessBoardId);
      }
      if (hasOpcode) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, Opcode);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static ChessBoardInfoReq ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ChessBoardInfoReq ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ChessBoardInfoReq ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ChessBoardInfoReq ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ChessBoardInfoReq ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ChessBoardInfoReq ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ChessBoardInfoReq ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ChessBoardInfoReq ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ChessBoardInfoReq ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ChessBoardInfoReq ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ChessBoardInfoReq MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ChessBoardInfoReq prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<ChessBoardInfoReq, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ChessBoardInfoReq cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ChessBoardInfoReq result;
      
      private ChessBoardInfoReq PrepareBuilder() {
        if (resultIsReadOnly) {
          ChessBoardInfoReq original = result;
          result = new ChessBoardInfoReq();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ChessBoardInfoReq MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.ChessBoardInfoReq.Descriptor; }
      }
      
      public override ChessBoardInfoReq DefaultInstanceForType {
        get { return global::MessageStruct.ChessBoardInfoReq.DefaultInstance; }
      }
      
      public override ChessBoardInfoReq BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ChessBoardInfoReq) {
          return MergeFrom((ChessBoardInfoReq) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ChessBoardInfoReq other) {
        if (other == global::MessageStruct.ChessBoardInfoReq.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasChessBoardId) {
          ChessBoardId = other.ChessBoardId;
        }
        if (other.HasOpcode) {
          Opcode = other.Opcode;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_chessBoardInfoReqFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _chessBoardInfoReqFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasChessBoardId = input.ReadInt32(ref result.chessBoardId_);
              break;
            }
            case 16: {
              result.hasOpcode = input.ReadInt32(ref result.opcode_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasChessBoardId {
        get { return result.hasChessBoardId; }
      }
      public int ChessBoardId {
        get { return result.ChessBoardId; }
        set { SetChessBoardId(value); }
      }
      public Builder SetChessBoardId(int value) {
        PrepareBuilder();
        result.hasChessBoardId = true;
        result.chessBoardId_ = value;
        return this;
      }
      public Builder ClearChessBoardId() {
        PrepareBuilder();
        result.hasChessBoardId = false;
        result.chessBoardId_ = 0;
        return this;
      }
      
      public bool HasOpcode {
        get { return result.hasOpcode; }
      }
      public int Opcode {
        get { return result.Opcode; }
        set { SetOpcode(value); }
      }
      public Builder SetOpcode(int value) {
        PrepareBuilder();
        result.hasOpcode = true;
        result.opcode_ = value;
        return this;
      }
      public Builder ClearOpcode() {
        PrepareBuilder();
        result.hasOpcode = false;
        result.opcode_ = 0;
        return this;
      }
    }
    static ChessBoardInfoReq() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class ChessBoardInfo : pb::GeneratedMessage<ChessBoardInfo, ChessBoardInfo.Builder> {
    private ChessBoardInfo() { }
    private static readonly ChessBoardInfo defaultInstance = new ChessBoardInfo().MakeReadOnly();
    private static readonly string[] _chessBoardInfoFieldNames = new string[] { "bottom_user", "id", "left_user", "people_num", "right_user" };
    private static readonly uint[] _chessBoardInfoFieldTags = new uint[] { 42, 8, 26, 16, 34 };
    public static ChessBoardInfo DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ChessBoardInfo DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ChessBoardInfo ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_ChessBoardInfo__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ChessBoardInfo, ChessBoardInfo.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_ChessBoardInfo__FieldAccessorTable; }
    }
    
    public const int IdFieldNumber = 1;
    private bool hasId;
    private uint id_;
    public bool HasId {
      get { return hasId; }
    }
    [global::System.CLSCompliant(false)]
    public uint Id {
      get { return id_; }
    }
    
    public const int PeopleNumFieldNumber = 2;
    private bool hasPeopleNum;
    private uint peopleNum_;
    public bool HasPeopleNum {
      get { return hasPeopleNum; }
    }
    [global::System.CLSCompliant(false)]
    public uint PeopleNum {
      get { return peopleNum_; }
    }
    
    public const int LeftUserFieldNumber = 3;
    private bool hasLeftUser;
    private global::MessageStruct.ChessBoardUser leftUser_;
    public bool HasLeftUser {
      get { return hasLeftUser; }
    }
    public global::MessageStruct.ChessBoardUser LeftUser {
      get { return leftUser_ ?? global::MessageStruct.ChessBoardUser.DefaultInstance; }
    }
    
    public const int RightUserFieldNumber = 4;
    private bool hasRightUser;
    private global::MessageStruct.ChessBoardUser rightUser_;
    public bool HasRightUser {
      get { return hasRightUser; }
    }
    public global::MessageStruct.ChessBoardUser RightUser {
      get { return rightUser_ ?? global::MessageStruct.ChessBoardUser.DefaultInstance; }
    }
    
    public const int BottomUserFieldNumber = 5;
    private bool hasBottomUser;
    private global::MessageStruct.ChessBoardUser bottomUser_;
    public bool HasBottomUser {
      get { return hasBottomUser; }
    }
    public global::MessageStruct.ChessBoardUser BottomUser {
      get { return bottomUser_ ?? global::MessageStruct.ChessBoardUser.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasId) return false;
        if (!hasPeopleNum) return false;
        if (!hasLeftUser) return false;
        if (!hasRightUser) return false;
        if (!hasBottomUser) return false;
        if (!LeftUser.IsInitialized) return false;
        if (!RightUser.IsInitialized) return false;
        if (!BottomUser.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _chessBoardInfoFieldNames;
      if (hasId) {
        output.WriteUInt32(1, field_names[1], Id);
      }
      if (hasPeopleNum) {
        output.WriteUInt32(2, field_names[3], PeopleNum);
      }
      if (hasLeftUser) {
        output.WriteMessage(3, field_names[2], LeftUser);
      }
      if (hasRightUser) {
        output.WriteMessage(4, field_names[4], RightUser);
      }
      if (hasBottomUser) {
        output.WriteMessage(5, field_names[0], BottomUser);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasId) {
        size += pb::CodedOutputStream.ComputeUInt32Size(1, Id);
      }
      if (hasPeopleNum) {
        size += pb::CodedOutputStream.ComputeUInt32Size(2, PeopleNum);
      }
      if (hasLeftUser) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, LeftUser);
      }
      if (hasRightUser) {
        size += pb::CodedOutputStream.ComputeMessageSize(4, RightUser);
      }
      if (hasBottomUser) {
        size += pb::CodedOutputStream.ComputeMessageSize(5, BottomUser);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static ChessBoardInfo ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ChessBoardInfo ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ChessBoardInfo ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ChessBoardInfo ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ChessBoardInfo ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ChessBoardInfo ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ChessBoardInfo ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ChessBoardInfo ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ChessBoardInfo ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ChessBoardInfo ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ChessBoardInfo MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ChessBoardInfo prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<ChessBoardInfo, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ChessBoardInfo cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ChessBoardInfo result;
      
      private ChessBoardInfo PrepareBuilder() {
        if (resultIsReadOnly) {
          ChessBoardInfo original = result;
          result = new ChessBoardInfo();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ChessBoardInfo MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.ChessBoardInfo.Descriptor; }
      }
      
      public override ChessBoardInfo DefaultInstanceForType {
        get { return global::MessageStruct.ChessBoardInfo.DefaultInstance; }
      }
      
      public override ChessBoardInfo BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ChessBoardInfo) {
          return MergeFrom((ChessBoardInfo) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ChessBoardInfo other) {
        if (other == global::MessageStruct.ChessBoardInfo.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasId) {
          Id = other.Id;
        }
        if (other.HasPeopleNum) {
          PeopleNum = other.PeopleNum;
        }
        if (other.HasLeftUser) {
          MergeLeftUser(other.LeftUser);
        }
        if (other.HasRightUser) {
          MergeRightUser(other.RightUser);
        }
        if (other.HasBottomUser) {
          MergeBottomUser(other.BottomUser);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_chessBoardInfoFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _chessBoardInfoFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasId = input.ReadUInt32(ref result.id_);
              break;
            }
            case 16: {
              result.hasPeopleNum = input.ReadUInt32(ref result.peopleNum_);
              break;
            }
            case 26: {
              global::MessageStruct.ChessBoardUser.Builder subBuilder = global::MessageStruct.ChessBoardUser.CreateBuilder();
              if (result.hasLeftUser) {
                subBuilder.MergeFrom(LeftUser);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              LeftUser = subBuilder.BuildPartial();
              break;
            }
            case 34: {
              global::MessageStruct.ChessBoardUser.Builder subBuilder = global::MessageStruct.ChessBoardUser.CreateBuilder();
              if (result.hasRightUser) {
                subBuilder.MergeFrom(RightUser);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              RightUser = subBuilder.BuildPartial();
              break;
            }
            case 42: {
              global::MessageStruct.ChessBoardUser.Builder subBuilder = global::MessageStruct.ChessBoardUser.CreateBuilder();
              if (result.hasBottomUser) {
                subBuilder.MergeFrom(BottomUser);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              BottomUser = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasId {
        get { return result.hasId; }
      }
      [global::System.CLSCompliant(false)]
      public uint Id {
        get { return result.Id; }
        set { SetId(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetId(uint value) {
        PrepareBuilder();
        result.hasId = true;
        result.id_ = value;
        return this;
      }
      public Builder ClearId() {
        PrepareBuilder();
        result.hasId = false;
        result.id_ = 0;
        return this;
      }
      
      public bool HasPeopleNum {
        get { return result.hasPeopleNum; }
      }
      [global::System.CLSCompliant(false)]
      public uint PeopleNum {
        get { return result.PeopleNum; }
        set { SetPeopleNum(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetPeopleNum(uint value) {
        PrepareBuilder();
        result.hasPeopleNum = true;
        result.peopleNum_ = value;
        return this;
      }
      public Builder ClearPeopleNum() {
        PrepareBuilder();
        result.hasPeopleNum = false;
        result.peopleNum_ = 0;
        return this;
      }
      
      public bool HasLeftUser {
       get { return result.hasLeftUser; }
      }
      public global::MessageStruct.ChessBoardUser LeftUser {
        get { return result.LeftUser; }
        set { SetLeftUser(value); }
      }
      public Builder SetLeftUser(global::MessageStruct.ChessBoardUser value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasLeftUser = true;
        result.leftUser_ = value;
        return this;
      }
      public Builder SetLeftUser(global::MessageStruct.ChessBoardUser.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasLeftUser = true;
        result.leftUser_ = builderForValue.Build();
        return this;
      }
      public Builder MergeLeftUser(global::MessageStruct.ChessBoardUser value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasLeftUser &&
            result.leftUser_ != global::MessageStruct.ChessBoardUser.DefaultInstance) {
            result.leftUser_ = global::MessageStruct.ChessBoardUser.CreateBuilder(result.leftUser_).MergeFrom(value).BuildPartial();
        } else {
          result.leftUser_ = value;
        }
        result.hasLeftUser = true;
        return this;
      }
      public Builder ClearLeftUser() {
        PrepareBuilder();
        result.hasLeftUser = false;
        result.leftUser_ = null;
        return this;
      }
      
      public bool HasRightUser {
       get { return result.hasRightUser; }
      }
      public global::MessageStruct.ChessBoardUser RightUser {
        get { return result.RightUser; }
        set { SetRightUser(value); }
      }
      public Builder SetRightUser(global::MessageStruct.ChessBoardUser value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRightUser = true;
        result.rightUser_ = value;
        return this;
      }
      public Builder SetRightUser(global::MessageStruct.ChessBoardUser.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasRightUser = true;
        result.rightUser_ = builderForValue.Build();
        return this;
      }
      public Builder MergeRightUser(global::MessageStruct.ChessBoardUser value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasRightUser &&
            result.rightUser_ != global::MessageStruct.ChessBoardUser.DefaultInstance) {
            result.rightUser_ = global::MessageStruct.ChessBoardUser.CreateBuilder(result.rightUser_).MergeFrom(value).BuildPartial();
        } else {
          result.rightUser_ = value;
        }
        result.hasRightUser = true;
        return this;
      }
      public Builder ClearRightUser() {
        PrepareBuilder();
        result.hasRightUser = false;
        result.rightUser_ = null;
        return this;
      }
      
      public bool HasBottomUser {
       get { return result.hasBottomUser; }
      }
      public global::MessageStruct.ChessBoardUser BottomUser {
        get { return result.BottomUser; }
        set { SetBottomUser(value); }
      }
      public Builder SetBottomUser(global::MessageStruct.ChessBoardUser value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasBottomUser = true;
        result.bottomUser_ = value;
        return this;
      }
      public Builder SetBottomUser(global::MessageStruct.ChessBoardUser.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasBottomUser = true;
        result.bottomUser_ = builderForValue.Build();
        return this;
      }
      public Builder MergeBottomUser(global::MessageStruct.ChessBoardUser value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasBottomUser &&
            result.bottomUser_ != global::MessageStruct.ChessBoardUser.DefaultInstance) {
            result.bottomUser_ = global::MessageStruct.ChessBoardUser.CreateBuilder(result.bottomUser_).MergeFrom(value).BuildPartial();
        } else {
          result.bottomUser_ = value;
        }
        result.hasBottomUser = true;
        return this;
      }
      public Builder ClearBottomUser() {
        PrepareBuilder();
        result.hasBottomUser = false;
        result.bottomUser_ = null;
        return this;
      }
    }
    static ChessBoardInfo() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class HallInfoReq : pb::GeneratedMessage<HallInfoReq, HallInfoReq.Builder> {
    private HallInfoReq() { }
    private static readonly HallInfoReq defaultInstance = new HallInfoReq().MakeReadOnly();
    private static readonly string[] _hallInfoReqFieldNames = new string[] { "game_hall_id", "opcode" };
    private static readonly uint[] _hallInfoReqFieldTags = new uint[] { 8, 16 };
    public static HallInfoReq DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override HallInfoReq DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override HallInfoReq ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_HallInfoReq__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<HallInfoReq, HallInfoReq.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_HallInfoReq__FieldAccessorTable; }
    }
    
    public const int GameHallIdFieldNumber = 1;
    private bool hasGameHallId;
    private int gameHallId_;
    public bool HasGameHallId {
      get { return hasGameHallId; }
    }
    public int GameHallId {
      get { return gameHallId_; }
    }
    
    public const int OpcodeFieldNumber = 2;
    private bool hasOpcode;
    private int opcode_;
    public bool HasOpcode {
      get { return hasOpcode; }
    }
    public int Opcode {
      get { return opcode_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasGameHallId) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _hallInfoReqFieldNames;
      if (hasGameHallId) {
        output.WriteInt32(1, field_names[0], GameHallId);
      }
      if (hasOpcode) {
        output.WriteInt32(2, field_names[1], Opcode);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasGameHallId) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, GameHallId);
      }
      if (hasOpcode) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, Opcode);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static HallInfoReq ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HallInfoReq ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HallInfoReq ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HallInfoReq ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HallInfoReq ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HallInfoReq ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static HallInfoReq ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static HallInfoReq ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static HallInfoReq ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HallInfoReq ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private HallInfoReq MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(HallInfoReq prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<HallInfoReq, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(HallInfoReq cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private HallInfoReq result;
      
      private HallInfoReq PrepareBuilder() {
        if (resultIsReadOnly) {
          HallInfoReq original = result;
          result = new HallInfoReq();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override HallInfoReq MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.HallInfoReq.Descriptor; }
      }
      
      public override HallInfoReq DefaultInstanceForType {
        get { return global::MessageStruct.HallInfoReq.DefaultInstance; }
      }
      
      public override HallInfoReq BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is HallInfoReq) {
          return MergeFrom((HallInfoReq) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(HallInfoReq other) {
        if (other == global::MessageStruct.HallInfoReq.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasGameHallId) {
          GameHallId = other.GameHallId;
        }
        if (other.HasOpcode) {
          Opcode = other.Opcode;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_hallInfoReqFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _hallInfoReqFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasGameHallId = input.ReadInt32(ref result.gameHallId_);
              break;
            }
            case 16: {
              result.hasOpcode = input.ReadInt32(ref result.opcode_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasGameHallId {
        get { return result.hasGameHallId; }
      }
      public int GameHallId {
        get { return result.GameHallId; }
        set { SetGameHallId(value); }
      }
      public Builder SetGameHallId(int value) {
        PrepareBuilder();
        result.hasGameHallId = true;
        result.gameHallId_ = value;
        return this;
      }
      public Builder ClearGameHallId() {
        PrepareBuilder();
        result.hasGameHallId = false;
        result.gameHallId_ = 0;
        return this;
      }
      
      public bool HasOpcode {
        get { return result.hasOpcode; }
      }
      public int Opcode {
        get { return result.Opcode; }
        set { SetOpcode(value); }
      }
      public Builder SetOpcode(int value) {
        PrepareBuilder();
        result.hasOpcode = true;
        result.opcode_ = value;
        return this;
      }
      public Builder ClearOpcode() {
        PrepareBuilder();
        result.hasOpcode = false;
        result.opcode_ = 0;
        return this;
      }
    }
    static HallInfoReq() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class HallInfo : pb::GeneratedMessage<HallInfo, HallInfo.Builder> {
    private HallInfo() { }
    private static readonly HallInfo defaultInstance = new HallInfo().MakeReadOnly();
    private static readonly string[] _hallInfoFieldNames = new string[] { "chess_board", "curr_people", "game_hall_id", "total_chessboard", "total_people" };
    private static readonly uint[] _hallInfoFieldTags = new uint[] { 42, 24, 8, 32, 16 };
    public static HallInfo DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override HallInfo DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override HallInfo ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_HallInfo__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<HallInfo, HallInfo.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_HallInfo__FieldAccessorTable; }
    }
    
    public const int GameHallIdFieldNumber = 1;
    private bool hasGameHallId;
    private int gameHallId_;
    public bool HasGameHallId {
      get { return hasGameHallId; }
    }
    public int GameHallId {
      get { return gameHallId_; }
    }
    
    public const int TotalPeopleFieldNumber = 2;
    private bool hasTotalPeople;
    private uint totalPeople_;
    public bool HasTotalPeople {
      get { return hasTotalPeople; }
    }
    [global::System.CLSCompliant(false)]
    public uint TotalPeople {
      get { return totalPeople_; }
    }
    
    public const int CurrPeopleFieldNumber = 3;
    private bool hasCurrPeople;
    private uint currPeople_;
    public bool HasCurrPeople {
      get { return hasCurrPeople; }
    }
    [global::System.CLSCompliant(false)]
    public uint CurrPeople {
      get { return currPeople_; }
    }
    
    public const int TotalChessboardFieldNumber = 4;
    private bool hasTotalChessboard;
    private uint totalChessboard_;
    public bool HasTotalChessboard {
      get { return hasTotalChessboard; }
    }
    [global::System.CLSCompliant(false)]
    public uint TotalChessboard {
      get { return totalChessboard_; }
    }
    
    public const int ChessBoardFieldNumber = 5;
    private pbc::PopsicleList<global::MessageStruct.ChessBoardInfo> chessBoard_ = new pbc::PopsicleList<global::MessageStruct.ChessBoardInfo>();
    public scg::IList<global::MessageStruct.ChessBoardInfo> ChessBoardList {
      get { return chessBoard_; }
    }
    public int ChessBoardCount {
      get { return chessBoard_.Count; }
    }
    public global::MessageStruct.ChessBoardInfo GetChessBoard(int index) {
      return chessBoard_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasGameHallId) return false;
        if (!hasTotalPeople) return false;
        if (!hasCurrPeople) return false;
        foreach (global::MessageStruct.ChessBoardInfo element in ChessBoardList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _hallInfoFieldNames;
      if (hasGameHallId) {
        output.WriteInt32(1, field_names[2], GameHallId);
      }
      if (hasTotalPeople) {
        output.WriteUInt32(2, field_names[4], TotalPeople);
      }
      if (hasCurrPeople) {
        output.WriteUInt32(3, field_names[1], CurrPeople);
      }
      if (hasTotalChessboard) {
        output.WriteUInt32(4, field_names[3], TotalChessboard);
      }
      if (chessBoard_.Count > 0) {
        output.WriteMessageArray(5, field_names[0], chessBoard_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasGameHallId) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, GameHallId);
      }
      if (hasTotalPeople) {
        size += pb::CodedOutputStream.ComputeUInt32Size(2, TotalPeople);
      }
      if (hasCurrPeople) {
        size += pb::CodedOutputStream.ComputeUInt32Size(3, CurrPeople);
      }
      if (hasTotalChessboard) {
        size += pb::CodedOutputStream.ComputeUInt32Size(4, TotalChessboard);
      }
      foreach (global::MessageStruct.ChessBoardInfo element in ChessBoardList) {
        size += pb::CodedOutputStream.ComputeMessageSize(5, element);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static HallInfo ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HallInfo ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HallInfo ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HallInfo ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HallInfo ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HallInfo ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static HallInfo ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static HallInfo ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static HallInfo ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HallInfo ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private HallInfo MakeReadOnly() {
      chessBoard_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(HallInfo prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<HallInfo, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(HallInfo cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private HallInfo result;
      
      private HallInfo PrepareBuilder() {
        if (resultIsReadOnly) {
          HallInfo original = result;
          result = new HallInfo();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override HallInfo MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.HallInfo.Descriptor; }
      }
      
      public override HallInfo DefaultInstanceForType {
        get { return global::MessageStruct.HallInfo.DefaultInstance; }
      }
      
      public override HallInfo BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is HallInfo) {
          return MergeFrom((HallInfo) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(HallInfo other) {
        if (other == global::MessageStruct.HallInfo.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasGameHallId) {
          GameHallId = other.GameHallId;
        }
        if (other.HasTotalPeople) {
          TotalPeople = other.TotalPeople;
        }
        if (other.HasCurrPeople) {
          CurrPeople = other.CurrPeople;
        }
        if (other.HasTotalChessboard) {
          TotalChessboard = other.TotalChessboard;
        }
        if (other.chessBoard_.Count != 0) {
          result.chessBoard_.Add(other.chessBoard_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_hallInfoFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _hallInfoFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasGameHallId = input.ReadInt32(ref result.gameHallId_);
              break;
            }
            case 16: {
              result.hasTotalPeople = input.ReadUInt32(ref result.totalPeople_);
              break;
            }
            case 24: {
              result.hasCurrPeople = input.ReadUInt32(ref result.currPeople_);
              break;
            }
            case 32: {
              result.hasTotalChessboard = input.ReadUInt32(ref result.totalChessboard_);
              break;
            }
            case 42: {
              input.ReadMessageArray(tag, field_name, result.chessBoard_, global::MessageStruct.ChessBoardInfo.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasGameHallId {
        get { return result.hasGameHallId; }
      }
      public int GameHallId {
        get { return result.GameHallId; }
        set { SetGameHallId(value); }
      }
      public Builder SetGameHallId(int value) {
        PrepareBuilder();
        result.hasGameHallId = true;
        result.gameHallId_ = value;
        return this;
      }
      public Builder ClearGameHallId() {
        PrepareBuilder();
        result.hasGameHallId = false;
        result.gameHallId_ = 0;
        return this;
      }
      
      public bool HasTotalPeople {
        get { return result.hasTotalPeople; }
      }
      [global::System.CLSCompliant(false)]
      public uint TotalPeople {
        get { return result.TotalPeople; }
        set { SetTotalPeople(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetTotalPeople(uint value) {
        PrepareBuilder();
        result.hasTotalPeople = true;
        result.totalPeople_ = value;
        return this;
      }
      public Builder ClearTotalPeople() {
        PrepareBuilder();
        result.hasTotalPeople = false;
        result.totalPeople_ = 0;
        return this;
      }
      
      public bool HasCurrPeople {
        get { return result.hasCurrPeople; }
      }
      [global::System.CLSCompliant(false)]
      public uint CurrPeople {
        get { return result.CurrPeople; }
        set { SetCurrPeople(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetCurrPeople(uint value) {
        PrepareBuilder();
        result.hasCurrPeople = true;
        result.currPeople_ = value;
        return this;
      }
      public Builder ClearCurrPeople() {
        PrepareBuilder();
        result.hasCurrPeople = false;
        result.currPeople_ = 0;
        return this;
      }
      
      public bool HasTotalChessboard {
        get { return result.hasTotalChessboard; }
      }
      [global::System.CLSCompliant(false)]
      public uint TotalChessboard {
        get { return result.TotalChessboard; }
        set { SetTotalChessboard(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetTotalChessboard(uint value) {
        PrepareBuilder();
        result.hasTotalChessboard = true;
        result.totalChessboard_ = value;
        return this;
      }
      public Builder ClearTotalChessboard() {
        PrepareBuilder();
        result.hasTotalChessboard = false;
        result.totalChessboard_ = 0;
        return this;
      }
      
      public pbc::IPopsicleList<global::MessageStruct.ChessBoardInfo> ChessBoardList {
        get { return PrepareBuilder().chessBoard_; }
      }
      public int ChessBoardCount {
        get { return result.ChessBoardCount; }
      }
      public global::MessageStruct.ChessBoardInfo GetChessBoard(int index) {
        return result.GetChessBoard(index);
      }
      public Builder SetChessBoard(int index, global::MessageStruct.ChessBoardInfo value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.chessBoard_[index] = value;
        return this;
      }
      public Builder SetChessBoard(int index, global::MessageStruct.ChessBoardInfo.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.chessBoard_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddChessBoard(global::MessageStruct.ChessBoardInfo value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.chessBoard_.Add(value);
        return this;
      }
      public Builder AddChessBoard(global::MessageStruct.ChessBoardInfo.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.chessBoard_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeChessBoard(scg::IEnumerable<global::MessageStruct.ChessBoardInfo> values) {
        PrepareBuilder();
        result.chessBoard_.Add(values);
        return this;
      }
      public Builder ClearChessBoard() {
        PrepareBuilder();
        result.chessBoard_.Clear();
        return this;
      }
    }
    static HallInfo() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class GameHallSumaryReq : pb::GeneratedMessage<GameHallSumaryReq, GameHallSumaryReq.Builder> {
    private GameHallSumaryReq() { }
    private static readonly GameHallSumaryReq defaultInstance = new GameHallSumaryReq().MakeReadOnly();
    private static readonly string[] _gameHallSumaryReqFieldNames = new string[] { "opcode" };
    private static readonly uint[] _gameHallSumaryReqFieldTags = new uint[] { 8 };
    public static GameHallSumaryReq DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GameHallSumaryReq DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GameHallSumaryReq ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_GameHallSumaryReq__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GameHallSumaryReq, GameHallSumaryReq.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_GameHallSumaryReq__FieldAccessorTable; }
    }
    
    public const int OpcodeFieldNumber = 1;
    private bool hasOpcode;
    private int opcode_;
    public bool HasOpcode {
      get { return hasOpcode; }
    }
    public int Opcode {
      get { return opcode_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _gameHallSumaryReqFieldNames;
      if (hasOpcode) {
        output.WriteInt32(1, field_names[0], Opcode);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasOpcode) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, Opcode);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static GameHallSumaryReq ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameHallSumaryReq ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameHallSumaryReq ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameHallSumaryReq ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameHallSumaryReq ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameHallSumaryReq ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GameHallSumaryReq ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GameHallSumaryReq ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GameHallSumaryReq ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameHallSumaryReq ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GameHallSumaryReq MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GameHallSumaryReq prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<GameHallSumaryReq, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GameHallSumaryReq cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GameHallSumaryReq result;
      
      private GameHallSumaryReq PrepareBuilder() {
        if (resultIsReadOnly) {
          GameHallSumaryReq original = result;
          result = new GameHallSumaryReq();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GameHallSumaryReq MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.GameHallSumaryReq.Descriptor; }
      }
      
      public override GameHallSumaryReq DefaultInstanceForType {
        get { return global::MessageStruct.GameHallSumaryReq.DefaultInstance; }
      }
      
      public override GameHallSumaryReq BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GameHallSumaryReq) {
          return MergeFrom((GameHallSumaryReq) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GameHallSumaryReq other) {
        if (other == global::MessageStruct.GameHallSumaryReq.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasOpcode) {
          Opcode = other.Opcode;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_gameHallSumaryReqFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _gameHallSumaryReqFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasOpcode = input.ReadInt32(ref result.opcode_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasOpcode {
        get { return result.hasOpcode; }
      }
      public int Opcode {
        get { return result.Opcode; }
        set { SetOpcode(value); }
      }
      public Builder SetOpcode(int value) {
        PrepareBuilder();
        result.hasOpcode = true;
        result.opcode_ = value;
        return this;
      }
      public Builder ClearOpcode() {
        PrepareBuilder();
        result.hasOpcode = false;
        result.opcode_ = 0;
        return this;
      }
    }
    static GameHallSumaryReq() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class GameHallSumary : pb::GeneratedMessage<GameHallSumary, GameHallSumary.Builder> {
    private GameHallSumary() { }
    private static readonly GameHallSumary defaultInstance = new GameHallSumary().MakeReadOnly();
    private static readonly string[] _gameHallSumaryFieldNames = new string[] { "account", "ad_picture1", "ad_picture2", "hall_info", "hall_num", "head_picture", "score", "username" };
    private static readonly uint[] _gameHallSumaryFieldTags = new uint[] { 10, 50, 58, 66, 32, 42, 24, 18 };
    public static GameHallSumary DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GameHallSumary DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GameHallSumary ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_GameHallSumary__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GameHallSumary, GameHallSumary.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_GameHallSumary__FieldAccessorTable; }
    }
    
    public const int AccountFieldNumber = 1;
    private bool hasAccount;
    private string account_ = "";
    public bool HasAccount {
      get { return hasAccount; }
    }
    public string Account {
      get { return account_; }
    }
    
    public const int UsernameFieldNumber = 2;
    private bool hasUsername;
    private string username_ = "";
    public bool HasUsername {
      get { return hasUsername; }
    }
    public string Username {
      get { return username_; }
    }
    
    public const int ScoreFieldNumber = 3;
    private bool hasScore;
    private int score_;
    public bool HasScore {
      get { return hasScore; }
    }
    public int Score {
      get { return score_; }
    }
    
    public const int HallNumFieldNumber = 4;
    private bool hasHallNum;
    private uint hallNum_;
    public bool HasHallNum {
      get { return hasHallNum; }
    }
    [global::System.CLSCompliant(false)]
    public uint HallNum {
      get { return hallNum_; }
    }
    
    public const int HeadPictureFieldNumber = 5;
    private bool hasHeadPicture;
    private string headPicture_ = "";
    public bool HasHeadPicture {
      get { return hasHeadPicture; }
    }
    public string HeadPicture {
      get { return headPicture_; }
    }
    
    public const int AdPicture1FieldNumber = 6;
    private bool hasAdPicture1;
    private string adPicture1_ = "";
    public bool HasAdPicture1 {
      get { return hasAdPicture1; }
    }
    public string AdPicture1 {
      get { return adPicture1_; }
    }
    
    public const int AdPicture2FieldNumber = 7;
    private bool hasAdPicture2;
    private string adPicture2_ = "";
    public bool HasAdPicture2 {
      get { return hasAdPicture2; }
    }
    public string AdPicture2 {
      get { return adPicture2_; }
    }
    
    public const int HallInfoFieldNumber = 8;
    private pbc::PopsicleList<global::MessageStruct.HallInfo> hallInfo_ = new pbc::PopsicleList<global::MessageStruct.HallInfo>();
    public scg::IList<global::MessageStruct.HallInfo> HallInfoList {
      get { return hallInfo_; }
    }
    public int HallInfoCount {
      get { return hallInfo_.Count; }
    }
    public global::MessageStruct.HallInfo GetHallInfo(int index) {
      return hallInfo_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasAccount) return false;
        if (!hasUsername) return false;
        if (!hasScore) return false;
        if (!hasHallNum) return false;
        if (!hasHeadPicture) return false;
        if (!hasAdPicture1) return false;
        foreach (global::MessageStruct.HallInfo element in HallInfoList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _gameHallSumaryFieldNames;
      if (hasAccount) {
        output.WriteString(1, field_names[0], Account);
      }
      if (hasUsername) {
        output.WriteString(2, field_names[7], Username);
      }
      if (hasScore) {
        output.WriteInt32(3, field_names[6], Score);
      }
      if (hasHallNum) {
        output.WriteUInt32(4, field_names[4], HallNum);
      }
      if (hasHeadPicture) {
        output.WriteString(5, field_names[5], HeadPicture);
      }
      if (hasAdPicture1) {
        output.WriteString(6, field_names[1], AdPicture1);
      }
      if (hasAdPicture2) {
        output.WriteString(7, field_names[2], AdPicture2);
      }
      if (hallInfo_.Count > 0) {
        output.WriteMessageArray(8, field_names[3], hallInfo_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasAccount) {
        size += pb::CodedOutputStream.ComputeStringSize(1, Account);
      }
      if (hasUsername) {
        size += pb::CodedOutputStream.ComputeStringSize(2, Username);
      }
      if (hasScore) {
        size += pb::CodedOutputStream.ComputeInt32Size(3, Score);
      }
      if (hasHallNum) {
        size += pb::CodedOutputStream.ComputeUInt32Size(4, HallNum);
      }
      if (hasHeadPicture) {
        size += pb::CodedOutputStream.ComputeStringSize(5, HeadPicture);
      }
      if (hasAdPicture1) {
        size += pb::CodedOutputStream.ComputeStringSize(6, AdPicture1);
      }
      if (hasAdPicture2) {
        size += pb::CodedOutputStream.ComputeStringSize(7, AdPicture2);
      }
      foreach (global::MessageStruct.HallInfo element in HallInfoList) {
        size += pb::CodedOutputStream.ComputeMessageSize(8, element);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static GameHallSumary ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameHallSumary ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameHallSumary ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameHallSumary ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameHallSumary ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameHallSumary ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GameHallSumary ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GameHallSumary ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GameHallSumary ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameHallSumary ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GameHallSumary MakeReadOnly() {
      hallInfo_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GameHallSumary prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<GameHallSumary, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GameHallSumary cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GameHallSumary result;
      
      private GameHallSumary PrepareBuilder() {
        if (resultIsReadOnly) {
          GameHallSumary original = result;
          result = new GameHallSumary();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GameHallSumary MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.GameHallSumary.Descriptor; }
      }
      
      public override GameHallSumary DefaultInstanceForType {
        get { return global::MessageStruct.GameHallSumary.DefaultInstance; }
      }
      
      public override GameHallSumary BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GameHallSumary) {
          return MergeFrom((GameHallSumary) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GameHallSumary other) {
        if (other == global::MessageStruct.GameHallSumary.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasAccount) {
          Account = other.Account;
        }
        if (other.HasUsername) {
          Username = other.Username;
        }
        if (other.HasScore) {
          Score = other.Score;
        }
        if (other.HasHallNum) {
          HallNum = other.HallNum;
        }
        if (other.HasHeadPicture) {
          HeadPicture = other.HeadPicture;
        }
        if (other.HasAdPicture1) {
          AdPicture1 = other.AdPicture1;
        }
        if (other.HasAdPicture2) {
          AdPicture2 = other.AdPicture2;
        }
        if (other.hallInfo_.Count != 0) {
          result.hallInfo_.Add(other.hallInfo_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_gameHallSumaryFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _gameHallSumaryFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasAccount = input.ReadString(ref result.account_);
              break;
            }
            case 18: {
              result.hasUsername = input.ReadString(ref result.username_);
              break;
            }
            case 24: {
              result.hasScore = input.ReadInt32(ref result.score_);
              break;
            }
            case 32: {
              result.hasHallNum = input.ReadUInt32(ref result.hallNum_);
              break;
            }
            case 42: {
              result.hasHeadPicture = input.ReadString(ref result.headPicture_);
              break;
            }
            case 50: {
              result.hasAdPicture1 = input.ReadString(ref result.adPicture1_);
              break;
            }
            case 58: {
              result.hasAdPicture2 = input.ReadString(ref result.adPicture2_);
              break;
            }
            case 66: {
              input.ReadMessageArray(tag, field_name, result.hallInfo_, global::MessageStruct.HallInfo.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasAccount {
        get { return result.hasAccount; }
      }
      public string Account {
        get { return result.Account; }
        set { SetAccount(value); }
      }
      public Builder SetAccount(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasAccount = true;
        result.account_ = value;
        return this;
      }
      public Builder ClearAccount() {
        PrepareBuilder();
        result.hasAccount = false;
        result.account_ = "";
        return this;
      }
      
      public bool HasUsername {
        get { return result.hasUsername; }
      }
      public string Username {
        get { return result.Username; }
        set { SetUsername(value); }
      }
      public Builder SetUsername(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasUsername = true;
        result.username_ = value;
        return this;
      }
      public Builder ClearUsername() {
        PrepareBuilder();
        result.hasUsername = false;
        result.username_ = "";
        return this;
      }
      
      public bool HasScore {
        get { return result.hasScore; }
      }
      public int Score {
        get { return result.Score; }
        set { SetScore(value); }
      }
      public Builder SetScore(int value) {
        PrepareBuilder();
        result.hasScore = true;
        result.score_ = value;
        return this;
      }
      public Builder ClearScore() {
        PrepareBuilder();
        result.hasScore = false;
        result.score_ = 0;
        return this;
      }
      
      public bool HasHallNum {
        get { return result.hasHallNum; }
      }
      [global::System.CLSCompliant(false)]
      public uint HallNum {
        get { return result.HallNum; }
        set { SetHallNum(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetHallNum(uint value) {
        PrepareBuilder();
        result.hasHallNum = true;
        result.hallNum_ = value;
        return this;
      }
      public Builder ClearHallNum() {
        PrepareBuilder();
        result.hasHallNum = false;
        result.hallNum_ = 0;
        return this;
      }
      
      public bool HasHeadPicture {
        get { return result.hasHeadPicture; }
      }
      public string HeadPicture {
        get { return result.HeadPicture; }
        set { SetHeadPicture(value); }
      }
      public Builder SetHeadPicture(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasHeadPicture = true;
        result.headPicture_ = value;
        return this;
      }
      public Builder ClearHeadPicture() {
        PrepareBuilder();
        result.hasHeadPicture = false;
        result.headPicture_ = "";
        return this;
      }
      
      public bool HasAdPicture1 {
        get { return result.hasAdPicture1; }
      }
      public string AdPicture1 {
        get { return result.AdPicture1; }
        set { SetAdPicture1(value); }
      }
      public Builder SetAdPicture1(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasAdPicture1 = true;
        result.adPicture1_ = value;
        return this;
      }
      public Builder ClearAdPicture1() {
        PrepareBuilder();
        result.hasAdPicture1 = false;
        result.adPicture1_ = "";
        return this;
      }
      
      public bool HasAdPicture2 {
        get { return result.hasAdPicture2; }
      }
      public string AdPicture2 {
        get { return result.AdPicture2; }
        set { SetAdPicture2(value); }
      }
      public Builder SetAdPicture2(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasAdPicture2 = true;
        result.adPicture2_ = value;
        return this;
      }
      public Builder ClearAdPicture2() {
        PrepareBuilder();
        result.hasAdPicture2 = false;
        result.adPicture2_ = "";
        return this;
      }
      
      public pbc::IPopsicleList<global::MessageStruct.HallInfo> HallInfoList {
        get { return PrepareBuilder().hallInfo_; }
      }
      public int HallInfoCount {
        get { return result.HallInfoCount; }
      }
      public global::MessageStruct.HallInfo GetHallInfo(int index) {
        return result.GetHallInfo(index);
      }
      public Builder SetHallInfo(int index, global::MessageStruct.HallInfo value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hallInfo_[index] = value;
        return this;
      }
      public Builder SetHallInfo(int index, global::MessageStruct.HallInfo.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hallInfo_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddHallInfo(global::MessageStruct.HallInfo value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hallInfo_.Add(value);
        return this;
      }
      public Builder AddHallInfo(global::MessageStruct.HallInfo.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hallInfo_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeHallInfo(scg::IEnumerable<global::MessageStruct.HallInfo> values) {
        PrepareBuilder();
        result.hallInfo_.Add(values);
        return this;
      }
      public Builder ClearHallInfo() {
        PrepareBuilder();
        result.hallInfo_.Clear();
        return this;
      }
    }
    static GameHallSumary() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class RequestPlay : pb::GeneratedMessage<RequestPlay, RequestPlay.Builder> {
    private RequestPlay() { }
    private static readonly RequestPlay defaultInstance = new RequestPlay().MakeReadOnly();
    private static readonly string[] _requestPlayFieldNames = new string[] { "chess_board_id", "game_hall_id", "locate" };
    private static readonly uint[] _requestPlayFieldTags = new uint[] { 16, 8, 24 };
    public static RequestPlay DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override RequestPlay DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override RequestPlay ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_RequestPlay__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<RequestPlay, RequestPlay.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_RequestPlay__FieldAccessorTable; }
    }
    
    public const int GameHallIdFieldNumber = 1;
    private bool hasGameHallId;
    private int gameHallId_;
    public bool HasGameHallId {
      get { return hasGameHallId; }
    }
    public int GameHallId {
      get { return gameHallId_; }
    }
    
    public const int ChessBoardIdFieldNumber = 2;
    private bool hasChessBoardId;
    private int chessBoardId_;
    public bool HasChessBoardId {
      get { return hasChessBoardId; }
    }
    public int ChessBoardId {
      get { return chessBoardId_; }
    }
    
    public const int LocateFieldNumber = 3;
    private bool hasLocate;
    private int locate_;
    public bool HasLocate {
      get { return hasLocate; }
    }
    public int Locate {
      get { return locate_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasGameHallId) return false;
        if (!hasChessBoardId) return false;
        if (!hasLocate) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _requestPlayFieldNames;
      if (hasGameHallId) {
        output.WriteInt32(1, field_names[1], GameHallId);
      }
      if (hasChessBoardId) {
        output.WriteInt32(2, field_names[0], ChessBoardId);
      }
      if (hasLocate) {
        output.WriteInt32(3, field_names[2], Locate);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasGameHallId) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, GameHallId);
      }
      if (hasChessBoardId) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, ChessBoardId);
      }
      if (hasLocate) {
        size += pb::CodedOutputStream.ComputeInt32Size(3, Locate);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static RequestPlay ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static RequestPlay ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static RequestPlay ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static RequestPlay ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static RequestPlay ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static RequestPlay ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static RequestPlay ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static RequestPlay ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static RequestPlay ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static RequestPlay ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private RequestPlay MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(RequestPlay prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<RequestPlay, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(RequestPlay cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private RequestPlay result;
      
      private RequestPlay PrepareBuilder() {
        if (resultIsReadOnly) {
          RequestPlay original = result;
          result = new RequestPlay();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override RequestPlay MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.RequestPlay.Descriptor; }
      }
      
      public override RequestPlay DefaultInstanceForType {
        get { return global::MessageStruct.RequestPlay.DefaultInstance; }
      }
      
      public override RequestPlay BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is RequestPlay) {
          return MergeFrom((RequestPlay) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(RequestPlay other) {
        if (other == global::MessageStruct.RequestPlay.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasGameHallId) {
          GameHallId = other.GameHallId;
        }
        if (other.HasChessBoardId) {
          ChessBoardId = other.ChessBoardId;
        }
        if (other.HasLocate) {
          Locate = other.Locate;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_requestPlayFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _requestPlayFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasGameHallId = input.ReadInt32(ref result.gameHallId_);
              break;
            }
            case 16: {
              result.hasChessBoardId = input.ReadInt32(ref result.chessBoardId_);
              break;
            }
            case 24: {
              result.hasLocate = input.ReadInt32(ref result.locate_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasGameHallId {
        get { return result.hasGameHallId; }
      }
      public int GameHallId {
        get { return result.GameHallId; }
        set { SetGameHallId(value); }
      }
      public Builder SetGameHallId(int value) {
        PrepareBuilder();
        result.hasGameHallId = true;
        result.gameHallId_ = value;
        return this;
      }
      public Builder ClearGameHallId() {
        PrepareBuilder();
        result.hasGameHallId = false;
        result.gameHallId_ = 0;
        return this;
      }
      
      public bool HasChessBoardId {
        get { return result.hasChessBoardId; }
      }
      public int ChessBoardId {
        get { return result.ChessBoardId; }
        set { SetChessBoardId(value); }
      }
      public Builder SetChessBoardId(int value) {
        PrepareBuilder();
        result.hasChessBoardId = true;
        result.chessBoardId_ = value;
        return this;
      }
      public Builder ClearChessBoardId() {
        PrepareBuilder();
        result.hasChessBoardId = false;
        result.chessBoardId_ = 0;
        return this;
      }
      
      public bool HasLocate {
        get { return result.hasLocate; }
      }
      public int Locate {
        get { return result.Locate; }
        set { SetLocate(value); }
      }
      public Builder SetLocate(int value) {
        PrepareBuilder();
        result.hasLocate = true;
        result.locate_ = value;
        return this;
      }
      public Builder ClearLocate() {
        PrepareBuilder();
        result.hasLocate = false;
        result.locate_ = 0;
        return this;
      }
    }
    static RequestPlay() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class RequestPlayReply : pb::GeneratedMessage<RequestPlayReply, RequestPlayReply.Builder> {
    private RequestPlayReply() { }
    private static readonly RequestPlayReply defaultInstance = new RequestPlayReply().MakeReadOnly();
    private static readonly string[] _requestPlayReplyFieldNames = new string[] { "chessBoard", "first_come_user_locate", "status" };
    private static readonly uint[] _requestPlayReplyFieldTags = new uint[] { 26, 16, 8 };
    public static RequestPlayReply DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override RequestPlayReply DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override RequestPlayReply ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_RequestPlayReply__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<RequestPlayReply, RequestPlayReply.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_RequestPlayReply__FieldAccessorTable; }
    }
    
    public const int StatusFieldNumber = 1;
    private bool hasStatus;
    private int status_;
    public bool HasStatus {
      get { return hasStatus; }
    }
    public int Status {
      get { return status_; }
    }
    
    public const int FirstComeUserLocateFieldNumber = 2;
    private bool hasFirstComeUserLocate;
    private uint firstComeUserLocate_;
    public bool HasFirstComeUserLocate {
      get { return hasFirstComeUserLocate; }
    }
    [global::System.CLSCompliant(false)]
    public uint FirstComeUserLocate {
      get { return firstComeUserLocate_; }
    }
    
    public const int ChessBoardFieldNumber = 3;
    private bool hasChessBoard;
    private global::MessageStruct.ChessBoardInfo chessBoard_;
    public bool HasChessBoard {
      get { return hasChessBoard; }
    }
    public global::MessageStruct.ChessBoardInfo ChessBoard {
      get { return chessBoard_ ?? global::MessageStruct.ChessBoardInfo.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasStatus) return false;
        if (!hasFirstComeUserLocate) return false;
        if (HasChessBoard) {
          if (!ChessBoard.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _requestPlayReplyFieldNames;
      if (hasStatus) {
        output.WriteInt32(1, field_names[2], Status);
      }
      if (hasFirstComeUserLocate) {
        output.WriteUInt32(2, field_names[1], FirstComeUserLocate);
      }
      if (hasChessBoard) {
        output.WriteMessage(3, field_names[0], ChessBoard);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasStatus) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, Status);
      }
      if (hasFirstComeUserLocate) {
        size += pb::CodedOutputStream.ComputeUInt32Size(2, FirstComeUserLocate);
      }
      if (hasChessBoard) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, ChessBoard);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static RequestPlayReply ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static RequestPlayReply ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static RequestPlayReply ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static RequestPlayReply ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static RequestPlayReply ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static RequestPlayReply ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static RequestPlayReply ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static RequestPlayReply ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static RequestPlayReply ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static RequestPlayReply ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private RequestPlayReply MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(RequestPlayReply prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<RequestPlayReply, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(RequestPlayReply cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private RequestPlayReply result;
      
      private RequestPlayReply PrepareBuilder() {
        if (resultIsReadOnly) {
          RequestPlayReply original = result;
          result = new RequestPlayReply();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override RequestPlayReply MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.RequestPlayReply.Descriptor; }
      }
      
      public override RequestPlayReply DefaultInstanceForType {
        get { return global::MessageStruct.RequestPlayReply.DefaultInstance; }
      }
      
      public override RequestPlayReply BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is RequestPlayReply) {
          return MergeFrom((RequestPlayReply) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(RequestPlayReply other) {
        if (other == global::MessageStruct.RequestPlayReply.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasStatus) {
          Status = other.Status;
        }
        if (other.HasFirstComeUserLocate) {
          FirstComeUserLocate = other.FirstComeUserLocate;
        }
        if (other.HasChessBoard) {
          MergeChessBoard(other.ChessBoard);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_requestPlayReplyFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _requestPlayReplyFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasStatus = input.ReadInt32(ref result.status_);
              break;
            }
            case 16: {
              result.hasFirstComeUserLocate = input.ReadUInt32(ref result.firstComeUserLocate_);
              break;
            }
            case 26: {
              global::MessageStruct.ChessBoardInfo.Builder subBuilder = global::MessageStruct.ChessBoardInfo.CreateBuilder();
              if (result.hasChessBoard) {
                subBuilder.MergeFrom(ChessBoard);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              ChessBoard = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasStatus {
        get { return result.hasStatus; }
      }
      public int Status {
        get { return result.Status; }
        set { SetStatus(value); }
      }
      public Builder SetStatus(int value) {
        PrepareBuilder();
        result.hasStatus = true;
        result.status_ = value;
        return this;
      }
      public Builder ClearStatus() {
        PrepareBuilder();
        result.hasStatus = false;
        result.status_ = 0;
        return this;
      }
      
      public bool HasFirstComeUserLocate {
        get { return result.hasFirstComeUserLocate; }
      }
      [global::System.CLSCompliant(false)]
      public uint FirstComeUserLocate {
        get { return result.FirstComeUserLocate; }
        set { SetFirstComeUserLocate(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetFirstComeUserLocate(uint value) {
        PrepareBuilder();
        result.hasFirstComeUserLocate = true;
        result.firstComeUserLocate_ = value;
        return this;
      }
      public Builder ClearFirstComeUserLocate() {
        PrepareBuilder();
        result.hasFirstComeUserLocate = false;
        result.firstComeUserLocate_ = 0;
        return this;
      }
      
      public bool HasChessBoard {
       get { return result.hasChessBoard; }
      }
      public global::MessageStruct.ChessBoardInfo ChessBoard {
        get { return result.ChessBoard; }
        set { SetChessBoard(value); }
      }
      public Builder SetChessBoard(global::MessageStruct.ChessBoardInfo value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasChessBoard = true;
        result.chessBoard_ = value;
        return this;
      }
      public Builder SetChessBoard(global::MessageStruct.ChessBoardInfo.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasChessBoard = true;
        result.chessBoard_ = builderForValue.Build();
        return this;
      }
      public Builder MergeChessBoard(global::MessageStruct.ChessBoardInfo value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasChessBoard &&
            result.chessBoard_ != global::MessageStruct.ChessBoardInfo.DefaultInstance) {
            result.chessBoard_ = global::MessageStruct.ChessBoardInfo.CreateBuilder(result.chessBoard_).MergeFrom(value).BuildPartial();
        } else {
          result.chessBoard_ = value;
        }
        result.hasChessBoard = true;
        return this;
      }
      public Builder ClearChessBoard() {
        PrepareBuilder();
        result.hasChessBoard = false;
        result.chessBoard_ = null;
        return this;
      }
    }
    static RequestPlayReply() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class MoveChess : pb::GeneratedMessage<MoveChess, MoveChess.Builder> {
    private MoveChess() { }
    private static readonly MoveChess defaultInstance = new MoveChess().MakeReadOnly();
    private static readonly string[] _moveChessFieldNames = new string[] { "des_pointX", "des_pointY", "eat_target_chess_type", "from_pointX", "from_pointY", "is_winner", "src_chess_type", "src_user_locate", "target_user_locate" };
    private static readonly uint[] _moveChessFieldTags = new uint[] { 40, 48, 64, 24, 32, 56, 8, 16, 72 };
    public static MoveChess DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override MoveChess DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override MoveChess ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_MoveChess__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<MoveChess, MoveChess.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_MoveChess__FieldAccessorTable; }
    }
    
    public const int SrcChessTypeFieldNumber = 1;
    private bool hasSrcChessType;
    private int srcChessType_;
    public bool HasSrcChessType {
      get { return hasSrcChessType; }
    }
    public int SrcChessType {
      get { return srcChessType_; }
    }
    
    public const int SrcUserLocateFieldNumber = 2;
    private bool hasSrcUserLocate;
    private int srcUserLocate_;
    public bool HasSrcUserLocate {
      get { return hasSrcUserLocate; }
    }
    public int SrcUserLocate {
      get { return srcUserLocate_; }
    }
    
    public const int FromPointXFieldNumber = 3;
    private bool hasFromPointX;
    private int fromPointX_;
    public bool HasFromPointX {
      get { return hasFromPointX; }
    }
    public int FromPointX {
      get { return fromPointX_; }
    }
    
    public const int FromPointYFieldNumber = 4;
    private bool hasFromPointY;
    private int fromPointY_;
    public bool HasFromPointY {
      get { return hasFromPointY; }
    }
    public int FromPointY {
      get { return fromPointY_; }
    }
    
    public const int DesPointXFieldNumber = 5;
    private bool hasDesPointX;
    private int desPointX_;
    public bool HasDesPointX {
      get { return hasDesPointX; }
    }
    public int DesPointX {
      get { return desPointX_; }
    }
    
    public const int DesPointYFieldNumber = 6;
    private bool hasDesPointY;
    private int desPointY_;
    public bool HasDesPointY {
      get { return hasDesPointY; }
    }
    public int DesPointY {
      get { return desPointY_; }
    }
    
    public const int IsWinnerFieldNumber = 7;
    private bool hasIsWinner;
    private bool isWinner_;
    public bool HasIsWinner {
      get { return hasIsWinner; }
    }
    public bool IsWinner {
      get { return isWinner_; }
    }
    
    public const int EatTargetChessTypeFieldNumber = 8;
    private bool hasEatTargetChessType;
    private int eatTargetChessType_;
    public bool HasEatTargetChessType {
      get { return hasEatTargetChessType; }
    }
    public int EatTargetChessType {
      get { return eatTargetChessType_; }
    }
    
    public const int TargetUserLocateFieldNumber = 9;
    private bool hasTargetUserLocate;
    private uint targetUserLocate_;
    public bool HasTargetUserLocate {
      get { return hasTargetUserLocate; }
    }
    [global::System.CLSCompliant(false)]
    public uint TargetUserLocate {
      get { return targetUserLocate_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasSrcChessType) return false;
        if (!hasSrcUserLocate) return false;
        if (!hasFromPointX) return false;
        if (!hasFromPointY) return false;
        if (!hasDesPointX) return false;
        if (!hasDesPointY) return false;
        if (!hasIsWinner) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _moveChessFieldNames;
      if (hasSrcChessType) {
        output.WriteInt32(1, field_names[6], SrcChessType);
      }
      if (hasSrcUserLocate) {
        output.WriteInt32(2, field_names[7], SrcUserLocate);
      }
      if (hasFromPointX) {
        output.WriteInt32(3, field_names[3], FromPointX);
      }
      if (hasFromPointY) {
        output.WriteInt32(4, field_names[4], FromPointY);
      }
      if (hasDesPointX) {
        output.WriteInt32(5, field_names[0], DesPointX);
      }
      if (hasDesPointY) {
        output.WriteInt32(6, field_names[1], DesPointY);
      }
      if (hasIsWinner) {
        output.WriteBool(7, field_names[5], IsWinner);
      }
      if (hasEatTargetChessType) {
        output.WriteInt32(8, field_names[2], EatTargetChessType);
      }
      if (hasTargetUserLocate) {
        output.WriteUInt32(9, field_names[8], TargetUserLocate);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasSrcChessType) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, SrcChessType);
      }
      if (hasSrcUserLocate) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, SrcUserLocate);
      }
      if (hasFromPointX) {
        size += pb::CodedOutputStream.ComputeInt32Size(3, FromPointX);
      }
      if (hasFromPointY) {
        size += pb::CodedOutputStream.ComputeInt32Size(4, FromPointY);
      }
      if (hasDesPointX) {
        size += pb::CodedOutputStream.ComputeInt32Size(5, DesPointX);
      }
      if (hasDesPointY) {
        size += pb::CodedOutputStream.ComputeInt32Size(6, DesPointY);
      }
      if (hasIsWinner) {
        size += pb::CodedOutputStream.ComputeBoolSize(7, IsWinner);
      }
      if (hasEatTargetChessType) {
        size += pb::CodedOutputStream.ComputeInt32Size(8, EatTargetChessType);
      }
      if (hasTargetUserLocate) {
        size += pb::CodedOutputStream.ComputeUInt32Size(9, TargetUserLocate);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static MoveChess ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MoveChess ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MoveChess ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MoveChess ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MoveChess ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MoveChess ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static MoveChess ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static MoveChess ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static MoveChess ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MoveChess ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private MoveChess MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(MoveChess prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<MoveChess, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(MoveChess cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private MoveChess result;
      
      private MoveChess PrepareBuilder() {
        if (resultIsReadOnly) {
          MoveChess original = result;
          result = new MoveChess();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override MoveChess MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.MoveChess.Descriptor; }
      }
      
      public override MoveChess DefaultInstanceForType {
        get { return global::MessageStruct.MoveChess.DefaultInstance; }
      }
      
      public override MoveChess BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is MoveChess) {
          return MergeFrom((MoveChess) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(MoveChess other) {
        if (other == global::MessageStruct.MoveChess.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasSrcChessType) {
          SrcChessType = other.SrcChessType;
        }
        if (other.HasSrcUserLocate) {
          SrcUserLocate = other.SrcUserLocate;
        }
        if (other.HasFromPointX) {
          FromPointX = other.FromPointX;
        }
        if (other.HasFromPointY) {
          FromPointY = other.FromPointY;
        }
        if (other.HasDesPointX) {
          DesPointX = other.DesPointX;
        }
        if (other.HasDesPointY) {
          DesPointY = other.DesPointY;
        }
        if (other.HasIsWinner) {
          IsWinner = other.IsWinner;
        }
        if (other.HasEatTargetChessType) {
          EatTargetChessType = other.EatTargetChessType;
        }
        if (other.HasTargetUserLocate) {
          TargetUserLocate = other.TargetUserLocate;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_moveChessFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _moveChessFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasSrcChessType = input.ReadInt32(ref result.srcChessType_);
              break;
            }
            case 16: {
              result.hasSrcUserLocate = input.ReadInt32(ref result.srcUserLocate_);
              break;
            }
            case 24: {
              result.hasFromPointX = input.ReadInt32(ref result.fromPointX_);
              break;
            }
            case 32: {
              result.hasFromPointY = input.ReadInt32(ref result.fromPointY_);
              break;
            }
            case 40: {
              result.hasDesPointX = input.ReadInt32(ref result.desPointX_);
              break;
            }
            case 48: {
              result.hasDesPointY = input.ReadInt32(ref result.desPointY_);
              break;
            }
            case 56: {
              result.hasIsWinner = input.ReadBool(ref result.isWinner_);
              break;
            }
            case 64: {
              result.hasEatTargetChessType = input.ReadInt32(ref result.eatTargetChessType_);
              break;
            }
            case 72: {
              result.hasTargetUserLocate = input.ReadUInt32(ref result.targetUserLocate_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasSrcChessType {
        get { return result.hasSrcChessType; }
      }
      public int SrcChessType {
        get { return result.SrcChessType; }
        set { SetSrcChessType(value); }
      }
      public Builder SetSrcChessType(int value) {
        PrepareBuilder();
        result.hasSrcChessType = true;
        result.srcChessType_ = value;
        return this;
      }
      public Builder ClearSrcChessType() {
        PrepareBuilder();
        result.hasSrcChessType = false;
        result.srcChessType_ = 0;
        return this;
      }
      
      public bool HasSrcUserLocate {
        get { return result.hasSrcUserLocate; }
      }
      public int SrcUserLocate {
        get { return result.SrcUserLocate; }
        set { SetSrcUserLocate(value); }
      }
      public Builder SetSrcUserLocate(int value) {
        PrepareBuilder();
        result.hasSrcUserLocate = true;
        result.srcUserLocate_ = value;
        return this;
      }
      public Builder ClearSrcUserLocate() {
        PrepareBuilder();
        result.hasSrcUserLocate = false;
        result.srcUserLocate_ = 0;
        return this;
      }
      
      public bool HasFromPointX {
        get { return result.hasFromPointX; }
      }
      public int FromPointX {
        get { return result.FromPointX; }
        set { SetFromPointX(value); }
      }
      public Builder SetFromPointX(int value) {
        PrepareBuilder();
        result.hasFromPointX = true;
        result.fromPointX_ = value;
        return this;
      }
      public Builder ClearFromPointX() {
        PrepareBuilder();
        result.hasFromPointX = false;
        result.fromPointX_ = 0;
        return this;
      }
      
      public bool HasFromPointY {
        get { return result.hasFromPointY; }
      }
      public int FromPointY {
        get { return result.FromPointY; }
        set { SetFromPointY(value); }
      }
      public Builder SetFromPointY(int value) {
        PrepareBuilder();
        result.hasFromPointY = true;
        result.fromPointY_ = value;
        return this;
      }
      public Builder ClearFromPointY() {
        PrepareBuilder();
        result.hasFromPointY = false;
        result.fromPointY_ = 0;
        return this;
      }
      
      public bool HasDesPointX {
        get { return result.hasDesPointX; }
      }
      public int DesPointX {
        get { return result.DesPointX; }
        set { SetDesPointX(value); }
      }
      public Builder SetDesPointX(int value) {
        PrepareBuilder();
        result.hasDesPointX = true;
        result.desPointX_ = value;
        return this;
      }
      public Builder ClearDesPointX() {
        PrepareBuilder();
        result.hasDesPointX = false;
        result.desPointX_ = 0;
        return this;
      }
      
      public bool HasDesPointY {
        get { return result.hasDesPointY; }
      }
      public int DesPointY {
        get { return result.DesPointY; }
        set { SetDesPointY(value); }
      }
      public Builder SetDesPointY(int value) {
        PrepareBuilder();
        result.hasDesPointY = true;
        result.desPointY_ = value;
        return this;
      }
      public Builder ClearDesPointY() {
        PrepareBuilder();
        result.hasDesPointY = false;
        result.desPointY_ = 0;
        return this;
      }
      
      public bool HasIsWinner {
        get { return result.hasIsWinner; }
      }
      public bool IsWinner {
        get { return result.IsWinner; }
        set { SetIsWinner(value); }
      }
      public Builder SetIsWinner(bool value) {
        PrepareBuilder();
        result.hasIsWinner = true;
        result.isWinner_ = value;
        return this;
      }
      public Builder ClearIsWinner() {
        PrepareBuilder();
        result.hasIsWinner = false;
        result.isWinner_ = false;
        return this;
      }
      
      public bool HasEatTargetChessType {
        get { return result.hasEatTargetChessType; }
      }
      public int EatTargetChessType {
        get { return result.EatTargetChessType; }
        set { SetEatTargetChessType(value); }
      }
      public Builder SetEatTargetChessType(int value) {
        PrepareBuilder();
        result.hasEatTargetChessType = true;
        result.eatTargetChessType_ = value;
        return this;
      }
      public Builder ClearEatTargetChessType() {
        PrepareBuilder();
        result.hasEatTargetChessType = false;
        result.eatTargetChessType_ = 0;
        return this;
      }
      
      public bool HasTargetUserLocate {
        get { return result.hasTargetUserLocate; }
      }
      [global::System.CLSCompliant(false)]
      public uint TargetUserLocate {
        get { return result.TargetUserLocate; }
        set { SetTargetUserLocate(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetTargetUserLocate(uint value) {
        PrepareBuilder();
        result.hasTargetUserLocate = true;
        result.targetUserLocate_ = value;
        return this;
      }
      public Builder ClearTargetUserLocate() {
        PrepareBuilder();
        result.hasTargetUserLocate = false;
        result.targetUserLocate_ = 0;
        return this;
      }
    }
    static MoveChess() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class MoveAction : pb::GeneratedMessage<MoveAction, MoveAction.Builder> {
    private MoveAction() { }
    private static readonly MoveAction defaultInstance = new MoveAction().MakeReadOnly();
    private static readonly string[] _moveActionFieldNames = new string[] { "movechess", "src_user_locate", "token_locate" };
    private static readonly uint[] _moveActionFieldTags = new uint[] { 18, 8, 24 };
    public static MoveAction DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override MoveAction DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override MoveAction ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_MoveAction__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<MoveAction, MoveAction.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_MoveAction__FieldAccessorTable; }
    }
    
    public const int SrcUserLocateFieldNumber = 1;
    private bool hasSrcUserLocate;
    private uint srcUserLocate_;
    public bool HasSrcUserLocate {
      get { return hasSrcUserLocate; }
    }
    [global::System.CLSCompliant(false)]
    public uint SrcUserLocate {
      get { return srcUserLocate_; }
    }
    
    public const int MovechessFieldNumber = 2;
    private bool hasMovechess;
    private global::MessageStruct.MoveChess movechess_;
    public bool HasMovechess {
      get { return hasMovechess; }
    }
    public global::MessageStruct.MoveChess Movechess {
      get { return movechess_ ?? global::MessageStruct.MoveChess.DefaultInstance; }
    }
    
    public const int TokenLocateFieldNumber = 3;
    private bool hasTokenLocate;
    private uint tokenLocate_;
    public bool HasTokenLocate {
      get { return hasTokenLocate; }
    }
    [global::System.CLSCompliant(false)]
    public uint TokenLocate {
      get { return tokenLocate_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasSrcUserLocate) return false;
        if (!hasMovechess) return false;
        if (!hasTokenLocate) return false;
        if (!Movechess.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _moveActionFieldNames;
      if (hasSrcUserLocate) {
        output.WriteUInt32(1, field_names[1], SrcUserLocate);
      }
      if (hasMovechess) {
        output.WriteMessage(2, field_names[0], Movechess);
      }
      if (hasTokenLocate) {
        output.WriteUInt32(3, field_names[2], TokenLocate);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasSrcUserLocate) {
        size += pb::CodedOutputStream.ComputeUInt32Size(1, SrcUserLocate);
      }
      if (hasMovechess) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, Movechess);
      }
      if (hasTokenLocate) {
        size += pb::CodedOutputStream.ComputeUInt32Size(3, TokenLocate);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static MoveAction ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MoveAction ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MoveAction ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MoveAction ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MoveAction ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MoveAction ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static MoveAction ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static MoveAction ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static MoveAction ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MoveAction ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private MoveAction MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(MoveAction prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<MoveAction, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(MoveAction cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private MoveAction result;
      
      private MoveAction PrepareBuilder() {
        if (resultIsReadOnly) {
          MoveAction original = result;
          result = new MoveAction();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override MoveAction MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.MoveAction.Descriptor; }
      }
      
      public override MoveAction DefaultInstanceForType {
        get { return global::MessageStruct.MoveAction.DefaultInstance; }
      }
      
      public override MoveAction BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is MoveAction) {
          return MergeFrom((MoveAction) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(MoveAction other) {
        if (other == global::MessageStruct.MoveAction.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasSrcUserLocate) {
          SrcUserLocate = other.SrcUserLocate;
        }
        if (other.HasMovechess) {
          MergeMovechess(other.Movechess);
        }
        if (other.HasTokenLocate) {
          TokenLocate = other.TokenLocate;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_moveActionFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _moveActionFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasSrcUserLocate = input.ReadUInt32(ref result.srcUserLocate_);
              break;
            }
            case 18: {
              global::MessageStruct.MoveChess.Builder subBuilder = global::MessageStruct.MoveChess.CreateBuilder();
              if (result.hasMovechess) {
                subBuilder.MergeFrom(Movechess);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Movechess = subBuilder.BuildPartial();
              break;
            }
            case 24: {
              result.hasTokenLocate = input.ReadUInt32(ref result.tokenLocate_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasSrcUserLocate {
        get { return result.hasSrcUserLocate; }
      }
      [global::System.CLSCompliant(false)]
      public uint SrcUserLocate {
        get { return result.SrcUserLocate; }
        set { SetSrcUserLocate(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetSrcUserLocate(uint value) {
        PrepareBuilder();
        result.hasSrcUserLocate = true;
        result.srcUserLocate_ = value;
        return this;
      }
      public Builder ClearSrcUserLocate() {
        PrepareBuilder();
        result.hasSrcUserLocate = false;
        result.srcUserLocate_ = 0;
        return this;
      }
      
      public bool HasMovechess {
       get { return result.hasMovechess; }
      }
      public global::MessageStruct.MoveChess Movechess {
        get { return result.Movechess; }
        set { SetMovechess(value); }
      }
      public Builder SetMovechess(global::MessageStruct.MoveChess value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMovechess = true;
        result.movechess_ = value;
        return this;
      }
      public Builder SetMovechess(global::MessageStruct.MoveChess.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasMovechess = true;
        result.movechess_ = builderForValue.Build();
        return this;
      }
      public Builder MergeMovechess(global::MessageStruct.MoveChess value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasMovechess &&
            result.movechess_ != global::MessageStruct.MoveChess.DefaultInstance) {
            result.movechess_ = global::MessageStruct.MoveChess.CreateBuilder(result.movechess_).MergeFrom(value).BuildPartial();
        } else {
          result.movechess_ = value;
        }
        result.hasMovechess = true;
        return this;
      }
      public Builder ClearMovechess() {
        PrepareBuilder();
        result.hasMovechess = false;
        result.movechess_ = null;
        return this;
      }
      
      public bool HasTokenLocate {
        get { return result.hasTokenLocate; }
      }
      [global::System.CLSCompliant(false)]
      public uint TokenLocate {
        get { return result.TokenLocate; }
        set { SetTokenLocate(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetTokenLocate(uint value) {
        PrepareBuilder();
        result.hasTokenLocate = true;
        result.tokenLocate_ = value;
        return this;
      }
      public Builder ClearTokenLocate() {
        PrepareBuilder();
        result.hasTokenLocate = false;
        result.tokenLocate_ = 0;
        return this;
      }
    }
    static MoveAction() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class UserMessage : pb::GeneratedMessage<UserMessage, UserMessage.Builder> {
    private UserMessage() { }
    private static readonly UserMessage defaultInstance = new UserMessage().MakeReadOnly();
    private static readonly string[] _userMessageFieldNames = new string[] { "msgContent", "src_user_locate" };
    private static readonly uint[] _userMessageFieldTags = new uint[] { 18, 8 };
    public static UserMessage DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override UserMessage DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override UserMessage ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_UserMessage__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<UserMessage, UserMessage.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_UserMessage__FieldAccessorTable; }
    }
    
    public const int SrcUserLocateFieldNumber = 1;
    private bool hasSrcUserLocate;
    private uint srcUserLocate_;
    public bool HasSrcUserLocate {
      get { return hasSrcUserLocate; }
    }
    [global::System.CLSCompliant(false)]
    public uint SrcUserLocate {
      get { return srcUserLocate_; }
    }
    
    public const int MsgContentFieldNumber = 2;
    private bool hasMsgContent;
    private string msgContent_ = "";
    public bool HasMsgContent {
      get { return hasMsgContent; }
    }
    public string MsgContent {
      get { return msgContent_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasSrcUserLocate) return false;
        if (!hasMsgContent) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _userMessageFieldNames;
      if (hasSrcUserLocate) {
        output.WriteUInt32(1, field_names[1], SrcUserLocate);
      }
      if (hasMsgContent) {
        output.WriteString(2, field_names[0], MsgContent);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasSrcUserLocate) {
        size += pb::CodedOutputStream.ComputeUInt32Size(1, SrcUserLocate);
      }
      if (hasMsgContent) {
        size += pb::CodedOutputStream.ComputeStringSize(2, MsgContent);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static UserMessage ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static UserMessage ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static UserMessage ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static UserMessage ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static UserMessage ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static UserMessage ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static UserMessage ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static UserMessage ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static UserMessage ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static UserMessage ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private UserMessage MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(UserMessage prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<UserMessage, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(UserMessage cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private UserMessage result;
      
      private UserMessage PrepareBuilder() {
        if (resultIsReadOnly) {
          UserMessage original = result;
          result = new UserMessage();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override UserMessage MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.UserMessage.Descriptor; }
      }
      
      public override UserMessage DefaultInstanceForType {
        get { return global::MessageStruct.UserMessage.DefaultInstance; }
      }
      
      public override UserMessage BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is UserMessage) {
          return MergeFrom((UserMessage) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(UserMessage other) {
        if (other == global::MessageStruct.UserMessage.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasSrcUserLocate) {
          SrcUserLocate = other.SrcUserLocate;
        }
        if (other.HasMsgContent) {
          MsgContent = other.MsgContent;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_userMessageFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _userMessageFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasSrcUserLocate = input.ReadUInt32(ref result.srcUserLocate_);
              break;
            }
            case 18: {
              result.hasMsgContent = input.ReadString(ref result.msgContent_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasSrcUserLocate {
        get { return result.hasSrcUserLocate; }
      }
      [global::System.CLSCompliant(false)]
      public uint SrcUserLocate {
        get { return result.SrcUserLocate; }
        set { SetSrcUserLocate(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetSrcUserLocate(uint value) {
        PrepareBuilder();
        result.hasSrcUserLocate = true;
        result.srcUserLocate_ = value;
        return this;
      }
      public Builder ClearSrcUserLocate() {
        PrepareBuilder();
        result.hasSrcUserLocate = false;
        result.srcUserLocate_ = 0;
        return this;
      }
      
      public bool HasMsgContent {
        get { return result.hasMsgContent; }
      }
      public string MsgContent {
        get { return result.MsgContent; }
        set { SetMsgContent(value); }
      }
      public Builder SetMsgContent(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMsgContent = true;
        result.msgContent_ = value;
        return this;
      }
      public Builder ClearMsgContent() {
        PrepareBuilder();
        result.hasMsgContent = false;
        result.msgContent_ = "";
        return this;
      }
    }
    static UserMessage() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class SystemMessage : pb::GeneratedMessage<SystemMessage, SystemMessage.Builder> {
    private SystemMessage() { }
    private static readonly SystemMessage defaultInstance = new SystemMessage().MakeReadOnly();
    private static readonly string[] _systemMessageFieldNames = new string[] { "msgContent" };
    private static readonly uint[] _systemMessageFieldTags = new uint[] { 10 };
    public static SystemMessage DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override SystemMessage DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override SystemMessage ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_SystemMessage__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<SystemMessage, SystemMessage.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_SystemMessage__FieldAccessorTable; }
    }
    
    public const int MsgContentFieldNumber = 1;
    private bool hasMsgContent;
    private string msgContent_ = "";
    public bool HasMsgContent {
      get { return hasMsgContent; }
    }
    public string MsgContent {
      get { return msgContent_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasMsgContent) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _systemMessageFieldNames;
      if (hasMsgContent) {
        output.WriteString(1, field_names[0], MsgContent);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasMsgContent) {
        size += pb::CodedOutputStream.ComputeStringSize(1, MsgContent);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static SystemMessage ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SystemMessage ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SystemMessage ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SystemMessage ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SystemMessage ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SystemMessage ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static SystemMessage ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static SystemMessage ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static SystemMessage ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SystemMessage ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private SystemMessage MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(SystemMessage prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<SystemMessage, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(SystemMessage cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private SystemMessage result;
      
      private SystemMessage PrepareBuilder() {
        if (resultIsReadOnly) {
          SystemMessage original = result;
          result = new SystemMessage();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override SystemMessage MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.SystemMessage.Descriptor; }
      }
      
      public override SystemMessage DefaultInstanceForType {
        get { return global::MessageStruct.SystemMessage.DefaultInstance; }
      }
      
      public override SystemMessage BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is SystemMessage) {
          return MergeFrom((SystemMessage) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(SystemMessage other) {
        if (other == global::MessageStruct.SystemMessage.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasMsgContent) {
          MsgContent = other.MsgContent;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_systemMessageFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _systemMessageFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasMsgContent = input.ReadString(ref result.msgContent_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasMsgContent {
        get { return result.hasMsgContent; }
      }
      public string MsgContent {
        get { return result.MsgContent; }
        set { SetMsgContent(value); }
      }
      public Builder SetMsgContent(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMsgContent = true;
        result.msgContent_ = value;
        return this;
      }
      public Builder ClearMsgContent() {
        PrepareBuilder();
        result.hasMsgContent = false;
        result.msgContent_ = "";
        return this;
      }
    }
    static SystemMessage() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Reconciled : pb::GeneratedMessage<Reconciled, Reconciled.Builder> {
    private Reconciled() { }
    private static readonly Reconciled defaultInstance = new Reconciled().MakeReadOnly();
    private static readonly string[] _reconciledFieldNames = new string[] { "apply_or_reply", "src_user_locate", "status", "tar_user_locate" };
    private static readonly uint[] _reconciledFieldTags = new uint[] { 8, 16, 34, 24 };
    public static Reconciled DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Reconciled DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Reconciled ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_Reconciled__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Reconciled, Reconciled.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_Reconciled__FieldAccessorTable; }
    }
    
    public const int ApplyOrReplyFieldNumber = 1;
    private bool hasApplyOrReply;
    private uint applyOrReply_;
    public bool HasApplyOrReply {
      get { return hasApplyOrReply; }
    }
    [global::System.CLSCompliant(false)]
    public uint ApplyOrReply {
      get { return applyOrReply_; }
    }
    
    public const int SrcUserLocateFieldNumber = 2;
    private bool hasSrcUserLocate;
    private uint srcUserLocate_;
    public bool HasSrcUserLocate {
      get { return hasSrcUserLocate; }
    }
    [global::System.CLSCompliant(false)]
    public uint SrcUserLocate {
      get { return srcUserLocate_; }
    }
    
    public const int TarUserLocateFieldNumber = 3;
    private bool hasTarUserLocate;
    private uint tarUserLocate_;
    public bool HasTarUserLocate {
      get { return hasTarUserLocate; }
    }
    [global::System.CLSCompliant(false)]
    public uint TarUserLocate {
      get { return tarUserLocate_; }
    }
    
    public const int StatusFieldNumber = 4;
    private bool hasStatus;
    private string status_ = "";
    public bool HasStatus {
      get { return hasStatus; }
    }
    public string Status {
      get { return status_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasApplyOrReply) return false;
        if (!hasSrcUserLocate) return false;
        if (!hasTarUserLocate) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _reconciledFieldNames;
      if (hasApplyOrReply) {
        output.WriteUInt32(1, field_names[0], ApplyOrReply);
      }
      if (hasSrcUserLocate) {
        output.WriteUInt32(2, field_names[1], SrcUserLocate);
      }
      if (hasTarUserLocate) {
        output.WriteUInt32(3, field_names[3], TarUserLocate);
      }
      if (hasStatus) {
        output.WriteString(4, field_names[2], Status);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasApplyOrReply) {
        size += pb::CodedOutputStream.ComputeUInt32Size(1, ApplyOrReply);
      }
      if (hasSrcUserLocate) {
        size += pb::CodedOutputStream.ComputeUInt32Size(2, SrcUserLocate);
      }
      if (hasTarUserLocate) {
        size += pb::CodedOutputStream.ComputeUInt32Size(3, TarUserLocate);
      }
      if (hasStatus) {
        size += pb::CodedOutputStream.ComputeStringSize(4, Status);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static Reconciled ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Reconciled ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Reconciled ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Reconciled ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Reconciled ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Reconciled ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Reconciled ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Reconciled ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Reconciled ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Reconciled ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Reconciled MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Reconciled prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Reconciled, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Reconciled cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Reconciled result;
      
      private Reconciled PrepareBuilder() {
        if (resultIsReadOnly) {
          Reconciled original = result;
          result = new Reconciled();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Reconciled MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.Reconciled.Descriptor; }
      }
      
      public override Reconciled DefaultInstanceForType {
        get { return global::MessageStruct.Reconciled.DefaultInstance; }
      }
      
      public override Reconciled BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Reconciled) {
          return MergeFrom((Reconciled) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Reconciled other) {
        if (other == global::MessageStruct.Reconciled.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasApplyOrReply) {
          ApplyOrReply = other.ApplyOrReply;
        }
        if (other.HasSrcUserLocate) {
          SrcUserLocate = other.SrcUserLocate;
        }
        if (other.HasTarUserLocate) {
          TarUserLocate = other.TarUserLocate;
        }
        if (other.HasStatus) {
          Status = other.Status;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_reconciledFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _reconciledFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasApplyOrReply = input.ReadUInt32(ref result.applyOrReply_);
              break;
            }
            case 16: {
              result.hasSrcUserLocate = input.ReadUInt32(ref result.srcUserLocate_);
              break;
            }
            case 24: {
              result.hasTarUserLocate = input.ReadUInt32(ref result.tarUserLocate_);
              break;
            }
            case 34: {
              result.hasStatus = input.ReadString(ref result.status_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasApplyOrReply {
        get { return result.hasApplyOrReply; }
      }
      [global::System.CLSCompliant(false)]
      public uint ApplyOrReply {
        get { return result.ApplyOrReply; }
        set { SetApplyOrReply(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetApplyOrReply(uint value) {
        PrepareBuilder();
        result.hasApplyOrReply = true;
        result.applyOrReply_ = value;
        return this;
      }
      public Builder ClearApplyOrReply() {
        PrepareBuilder();
        result.hasApplyOrReply = false;
        result.applyOrReply_ = 0;
        return this;
      }
      
      public bool HasSrcUserLocate {
        get { return result.hasSrcUserLocate; }
      }
      [global::System.CLSCompliant(false)]
      public uint SrcUserLocate {
        get { return result.SrcUserLocate; }
        set { SetSrcUserLocate(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetSrcUserLocate(uint value) {
        PrepareBuilder();
        result.hasSrcUserLocate = true;
        result.srcUserLocate_ = value;
        return this;
      }
      public Builder ClearSrcUserLocate() {
        PrepareBuilder();
        result.hasSrcUserLocate = false;
        result.srcUserLocate_ = 0;
        return this;
      }
      
      public bool HasTarUserLocate {
        get { return result.hasTarUserLocate; }
      }
      [global::System.CLSCompliant(false)]
      public uint TarUserLocate {
        get { return result.TarUserLocate; }
        set { SetTarUserLocate(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetTarUserLocate(uint value) {
        PrepareBuilder();
        result.hasTarUserLocate = true;
        result.tarUserLocate_ = value;
        return this;
      }
      public Builder ClearTarUserLocate() {
        PrepareBuilder();
        result.hasTarUserLocate = false;
        result.tarUserLocate_ = 0;
        return this;
      }
      
      public bool HasStatus {
        get { return result.hasStatus; }
      }
      public string Status {
        get { return result.Status; }
        set { SetStatus(value); }
      }
      public Builder SetStatus(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasStatus = true;
        result.status_ = value;
        return this;
      }
      public Builder ClearStatus() {
        PrepareBuilder();
        result.hasStatus = false;
        result.status_ = "";
        return this;
      }
    }
    static Reconciled() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class GiveUp : pb::GeneratedMessage<GiveUp, GiveUp.Builder> {
    private GiveUp() { }
    private static readonly GiveUp defaultInstance = new GiveUp().MakeReadOnly();
    private static readonly string[] _giveUpFieldNames = new string[] { "opt", "src_user_locate" };
    private static readonly uint[] _giveUpFieldTags = new uint[] { 18, 8 };
    public static GiveUp DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GiveUp DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GiveUp ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_GiveUp__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GiveUp, GiveUp.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_GiveUp__FieldAccessorTable; }
    }
    
    public const int SrcUserLocateFieldNumber = 1;
    private bool hasSrcUserLocate;
    private uint srcUserLocate_;
    public bool HasSrcUserLocate {
      get { return hasSrcUserLocate; }
    }
    [global::System.CLSCompliant(false)]
    public uint SrcUserLocate {
      get { return srcUserLocate_; }
    }
    
    public const int OptFieldNumber = 2;
    private bool hasOpt;
    private string opt_ = "";
    public bool HasOpt {
      get { return hasOpt; }
    }
    public string Opt {
      get { return opt_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasSrcUserLocate) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _giveUpFieldNames;
      if (hasSrcUserLocate) {
        output.WriteUInt32(1, field_names[1], SrcUserLocate);
      }
      if (hasOpt) {
        output.WriteString(2, field_names[0], Opt);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasSrcUserLocate) {
        size += pb::CodedOutputStream.ComputeUInt32Size(1, SrcUserLocate);
      }
      if (hasOpt) {
        size += pb::CodedOutputStream.ComputeStringSize(2, Opt);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static GiveUp ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GiveUp ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GiveUp ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GiveUp ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GiveUp ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GiveUp ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GiveUp ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GiveUp ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GiveUp ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GiveUp ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GiveUp MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GiveUp prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<GiveUp, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GiveUp cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GiveUp result;
      
      private GiveUp PrepareBuilder() {
        if (resultIsReadOnly) {
          GiveUp original = result;
          result = new GiveUp();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GiveUp MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.GiveUp.Descriptor; }
      }
      
      public override GiveUp DefaultInstanceForType {
        get { return global::MessageStruct.GiveUp.DefaultInstance; }
      }
      
      public override GiveUp BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GiveUp) {
          return MergeFrom((GiveUp) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GiveUp other) {
        if (other == global::MessageStruct.GiveUp.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasSrcUserLocate) {
          SrcUserLocate = other.SrcUserLocate;
        }
        if (other.HasOpt) {
          Opt = other.Opt;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_giveUpFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _giveUpFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasSrcUserLocate = input.ReadUInt32(ref result.srcUserLocate_);
              break;
            }
            case 18: {
              result.hasOpt = input.ReadString(ref result.opt_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasSrcUserLocate {
        get { return result.hasSrcUserLocate; }
      }
      [global::System.CLSCompliant(false)]
      public uint SrcUserLocate {
        get { return result.SrcUserLocate; }
        set { SetSrcUserLocate(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetSrcUserLocate(uint value) {
        PrepareBuilder();
        result.hasSrcUserLocate = true;
        result.srcUserLocate_ = value;
        return this;
      }
      public Builder ClearSrcUserLocate() {
        PrepareBuilder();
        result.hasSrcUserLocate = false;
        result.srcUserLocate_ = 0;
        return this;
      }
      
      public bool HasOpt {
        get { return result.hasOpt; }
      }
      public string Opt {
        get { return result.Opt; }
        set { SetOpt(value); }
      }
      public Builder SetOpt(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasOpt = true;
        result.opt_ = value;
        return this;
      }
      public Builder ClearOpt() {
        PrepareBuilder();
        result.hasOpt = false;
        result.opt_ = "";
        return this;
      }
    }
    static GiveUp() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Undo : pb::GeneratedMessage<Undo, Undo.Builder> {
    private Undo() { }
    private static readonly Undo defaultInstance = new Undo().MakeReadOnly();
    private static readonly string[] _undoFieldNames = new string[] { "rep_or_respon", "src_user_locate", "status", "tar_user_locate" };
    private static readonly uint[] _undoFieldTags = new uint[] { 8, 16, 32, 24 };
    public static Undo DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Undo DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Undo ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_Undo__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Undo, Undo.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_Undo__FieldAccessorTable; }
    }
    
    public const int RepOrResponFieldNumber = 1;
    private bool hasRepOrRespon;
    private uint repOrRespon_;
    public bool HasRepOrRespon {
      get { return hasRepOrRespon; }
    }
    [global::System.CLSCompliant(false)]
    public uint RepOrRespon {
      get { return repOrRespon_; }
    }
    
    public const int SrcUserLocateFieldNumber = 2;
    private bool hasSrcUserLocate;
    private uint srcUserLocate_;
    public bool HasSrcUserLocate {
      get { return hasSrcUserLocate; }
    }
    [global::System.CLSCompliant(false)]
    public uint SrcUserLocate {
      get { return srcUserLocate_; }
    }
    
    public const int TarUserLocateFieldNumber = 3;
    private bool hasTarUserLocate;
    private uint tarUserLocate_;
    public bool HasTarUserLocate {
      get { return hasTarUserLocate; }
    }
    [global::System.CLSCompliant(false)]
    public uint TarUserLocate {
      get { return tarUserLocate_; }
    }
    
    public const int StatusFieldNumber = 4;
    private bool hasStatus;
    private bool status_;
    public bool HasStatus {
      get { return hasStatus; }
    }
    public bool Status {
      get { return status_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasRepOrRespon) return false;
        if (!hasSrcUserLocate) return false;
        if (!hasTarUserLocate) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _undoFieldNames;
      if (hasRepOrRespon) {
        output.WriteUInt32(1, field_names[0], RepOrRespon);
      }
      if (hasSrcUserLocate) {
        output.WriteUInt32(2, field_names[1], SrcUserLocate);
      }
      if (hasTarUserLocate) {
        output.WriteUInt32(3, field_names[3], TarUserLocate);
      }
      if (hasStatus) {
        output.WriteBool(4, field_names[2], Status);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasRepOrRespon) {
        size += pb::CodedOutputStream.ComputeUInt32Size(1, RepOrRespon);
      }
      if (hasSrcUserLocate) {
        size += pb::CodedOutputStream.ComputeUInt32Size(2, SrcUserLocate);
      }
      if (hasTarUserLocate) {
        size += pb::CodedOutputStream.ComputeUInt32Size(3, TarUserLocate);
      }
      if (hasStatus) {
        size += pb::CodedOutputStream.ComputeBoolSize(4, Status);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static Undo ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Undo ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Undo ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Undo ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Undo ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Undo ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Undo ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Undo ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Undo ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Undo ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Undo MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Undo prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Undo, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Undo cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Undo result;
      
      private Undo PrepareBuilder() {
        if (resultIsReadOnly) {
          Undo original = result;
          result = new Undo();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Undo MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.Undo.Descriptor; }
      }
      
      public override Undo DefaultInstanceForType {
        get { return global::MessageStruct.Undo.DefaultInstance; }
      }
      
      public override Undo BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Undo) {
          return MergeFrom((Undo) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Undo other) {
        if (other == global::MessageStruct.Undo.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasRepOrRespon) {
          RepOrRespon = other.RepOrRespon;
        }
        if (other.HasSrcUserLocate) {
          SrcUserLocate = other.SrcUserLocate;
        }
        if (other.HasTarUserLocate) {
          TarUserLocate = other.TarUserLocate;
        }
        if (other.HasStatus) {
          Status = other.Status;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_undoFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _undoFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasRepOrRespon = input.ReadUInt32(ref result.repOrRespon_);
              break;
            }
            case 16: {
              result.hasSrcUserLocate = input.ReadUInt32(ref result.srcUserLocate_);
              break;
            }
            case 24: {
              result.hasTarUserLocate = input.ReadUInt32(ref result.tarUserLocate_);
              break;
            }
            case 32: {
              result.hasStatus = input.ReadBool(ref result.status_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasRepOrRespon {
        get { return result.hasRepOrRespon; }
      }
      [global::System.CLSCompliant(false)]
      public uint RepOrRespon {
        get { return result.RepOrRespon; }
        set { SetRepOrRespon(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetRepOrRespon(uint value) {
        PrepareBuilder();
        result.hasRepOrRespon = true;
        result.repOrRespon_ = value;
        return this;
      }
      public Builder ClearRepOrRespon() {
        PrepareBuilder();
        result.hasRepOrRespon = false;
        result.repOrRespon_ = 0;
        return this;
      }
      
      public bool HasSrcUserLocate {
        get { return result.hasSrcUserLocate; }
      }
      [global::System.CLSCompliant(false)]
      public uint SrcUserLocate {
        get { return result.SrcUserLocate; }
        set { SetSrcUserLocate(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetSrcUserLocate(uint value) {
        PrepareBuilder();
        result.hasSrcUserLocate = true;
        result.srcUserLocate_ = value;
        return this;
      }
      public Builder ClearSrcUserLocate() {
        PrepareBuilder();
        result.hasSrcUserLocate = false;
        result.srcUserLocate_ = 0;
        return this;
      }
      
      public bool HasTarUserLocate {
        get { return result.hasTarUserLocate; }
      }
      [global::System.CLSCompliant(false)]
      public uint TarUserLocate {
        get { return result.TarUserLocate; }
        set { SetTarUserLocate(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetTarUserLocate(uint value) {
        PrepareBuilder();
        result.hasTarUserLocate = true;
        result.tarUserLocate_ = value;
        return this;
      }
      public Builder ClearTarUserLocate() {
        PrepareBuilder();
        result.hasTarUserLocate = false;
        result.tarUserLocate_ = 0;
        return this;
      }
      
      public bool HasStatus {
        get { return result.hasStatus; }
      }
      public bool Status {
        get { return result.Status; }
        set { SetStatus(value); }
      }
      public Builder SetStatus(bool value) {
        PrepareBuilder();
        result.hasStatus = true;
        result.status_ = value;
        return this;
      }
      public Builder ClearStatus() {
        PrepareBuilder();
        result.hasStatus = false;
        result.status_ = false;
        return this;
      }
    }
    static Undo() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class GameReadyReq : pb::GeneratedMessage<GameReadyReq, GameReadyReq.Builder> {
    private GameReadyReq() { }
    private static readonly GameReadyReq defaultInstance = new GameReadyReq().MakeReadOnly();
    private static readonly string[] _gameReadyReqFieldNames = new string[] { "opcode", "single_step_time", "src_user_locate", "total_time" };
    private static readonly uint[] _gameReadyReqFieldTags = new uint[] { 16, 32, 8, 24 };
    public static GameReadyReq DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GameReadyReq DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GameReadyReq ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_GameReadyReq__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GameReadyReq, GameReadyReq.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_GameReadyReq__FieldAccessorTable; }
    }
    
    public const int SrcUserLocateFieldNumber = 1;
    private bool hasSrcUserLocate;
    private uint srcUserLocate_;
    public bool HasSrcUserLocate {
      get { return hasSrcUserLocate; }
    }
    [global::System.CLSCompliant(false)]
    public uint SrcUserLocate {
      get { return srcUserLocate_; }
    }
    
    public const int OpcodeFieldNumber = 2;
    private bool hasOpcode;
    private uint opcode_;
    public bool HasOpcode {
      get { return hasOpcode; }
    }
    [global::System.CLSCompliant(false)]
    public uint Opcode {
      get { return opcode_; }
    }
    
    public const int TotalTimeFieldNumber = 3;
    private bool hasTotalTime;
    private uint totalTime_;
    public bool HasTotalTime {
      get { return hasTotalTime; }
    }
    [global::System.CLSCompliant(false)]
    public uint TotalTime {
      get { return totalTime_; }
    }
    
    public const int SingleStepTimeFieldNumber = 4;
    private bool hasSingleStepTime;
    private uint singleStepTime_;
    public bool HasSingleStepTime {
      get { return hasSingleStepTime; }
    }
    [global::System.CLSCompliant(false)]
    public uint SingleStepTime {
      get { return singleStepTime_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasSrcUserLocate) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _gameReadyReqFieldNames;
      if (hasSrcUserLocate) {
        output.WriteUInt32(1, field_names[2], SrcUserLocate);
      }
      if (hasOpcode) {
        output.WriteUInt32(2, field_names[0], Opcode);
      }
      if (hasTotalTime) {
        output.WriteUInt32(3, field_names[3], TotalTime);
      }
      if (hasSingleStepTime) {
        output.WriteUInt32(4, field_names[1], SingleStepTime);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasSrcUserLocate) {
        size += pb::CodedOutputStream.ComputeUInt32Size(1, SrcUserLocate);
      }
      if (hasOpcode) {
        size += pb::CodedOutputStream.ComputeUInt32Size(2, Opcode);
      }
      if (hasTotalTime) {
        size += pb::CodedOutputStream.ComputeUInt32Size(3, TotalTime);
      }
      if (hasSingleStepTime) {
        size += pb::CodedOutputStream.ComputeUInt32Size(4, SingleStepTime);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static GameReadyReq ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameReadyReq ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameReadyReq ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameReadyReq ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameReadyReq ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameReadyReq ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GameReadyReq ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GameReadyReq ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GameReadyReq ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameReadyReq ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GameReadyReq MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GameReadyReq prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<GameReadyReq, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GameReadyReq cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GameReadyReq result;
      
      private GameReadyReq PrepareBuilder() {
        if (resultIsReadOnly) {
          GameReadyReq original = result;
          result = new GameReadyReq();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GameReadyReq MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.GameReadyReq.Descriptor; }
      }
      
      public override GameReadyReq DefaultInstanceForType {
        get { return global::MessageStruct.GameReadyReq.DefaultInstance; }
      }
      
      public override GameReadyReq BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GameReadyReq) {
          return MergeFrom((GameReadyReq) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GameReadyReq other) {
        if (other == global::MessageStruct.GameReadyReq.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasSrcUserLocate) {
          SrcUserLocate = other.SrcUserLocate;
        }
        if (other.HasOpcode) {
          Opcode = other.Opcode;
        }
        if (other.HasTotalTime) {
          TotalTime = other.TotalTime;
        }
        if (other.HasSingleStepTime) {
          SingleStepTime = other.SingleStepTime;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_gameReadyReqFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _gameReadyReqFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasSrcUserLocate = input.ReadUInt32(ref result.srcUserLocate_);
              break;
            }
            case 16: {
              result.hasOpcode = input.ReadUInt32(ref result.opcode_);
              break;
            }
            case 24: {
              result.hasTotalTime = input.ReadUInt32(ref result.totalTime_);
              break;
            }
            case 32: {
              result.hasSingleStepTime = input.ReadUInt32(ref result.singleStepTime_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasSrcUserLocate {
        get { return result.hasSrcUserLocate; }
      }
      [global::System.CLSCompliant(false)]
      public uint SrcUserLocate {
        get { return result.SrcUserLocate; }
        set { SetSrcUserLocate(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetSrcUserLocate(uint value) {
        PrepareBuilder();
        result.hasSrcUserLocate = true;
        result.srcUserLocate_ = value;
        return this;
      }
      public Builder ClearSrcUserLocate() {
        PrepareBuilder();
        result.hasSrcUserLocate = false;
        result.srcUserLocate_ = 0;
        return this;
      }
      
      public bool HasOpcode {
        get { return result.hasOpcode; }
      }
      [global::System.CLSCompliant(false)]
      public uint Opcode {
        get { return result.Opcode; }
        set { SetOpcode(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetOpcode(uint value) {
        PrepareBuilder();
        result.hasOpcode = true;
        result.opcode_ = value;
        return this;
      }
      public Builder ClearOpcode() {
        PrepareBuilder();
        result.hasOpcode = false;
        result.opcode_ = 0;
        return this;
      }
      
      public bool HasTotalTime {
        get { return result.hasTotalTime; }
      }
      [global::System.CLSCompliant(false)]
      public uint TotalTime {
        get { return result.TotalTime; }
        set { SetTotalTime(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetTotalTime(uint value) {
        PrepareBuilder();
        result.hasTotalTime = true;
        result.totalTime_ = value;
        return this;
      }
      public Builder ClearTotalTime() {
        PrepareBuilder();
        result.hasTotalTime = false;
        result.totalTime_ = 0;
        return this;
      }
      
      public bool HasSingleStepTime {
        get { return result.hasSingleStepTime; }
      }
      [global::System.CLSCompliant(false)]
      public uint SingleStepTime {
        get { return result.SingleStepTime; }
        set { SetSingleStepTime(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetSingleStepTime(uint value) {
        PrepareBuilder();
        result.hasSingleStepTime = true;
        result.singleStepTime_ = value;
        return this;
      }
      public Builder ClearSingleStepTime() {
        PrepareBuilder();
        result.hasSingleStepTime = false;
        result.singleStepTime_ = 0;
        return this;
      }
    }
    static GameReadyReq() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class GameStatusReply : pb::GeneratedMessage<GameStatusReply, GameStatusReply.Builder> {
    private GameStatusReply() { }
    private static readonly GameStatusReply defaultInstance = new GameStatusReply().MakeReadOnly();
    private static readonly string[] _gameStatusReplyFieldNames = new string[] { "bottom_user_status", "left_user_status", "right_user_status", "single_step_time", "token_locate", "total_time" };
    private static readonly uint[] _gameStatusReplyFieldTags = new uint[] { 24, 8, 16, 48, 32, 40 };
    public static GameStatusReply DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GameStatusReply DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GameStatusReply ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_GameStatusReply__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GameStatusReply, GameStatusReply.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_GameStatusReply__FieldAccessorTable; }
    }
    
    public const int LeftUserStatusFieldNumber = 1;
    private bool hasLeftUserStatus;
    private bool leftUserStatus_;
    public bool HasLeftUserStatus {
      get { return hasLeftUserStatus; }
    }
    public bool LeftUserStatus {
      get { return leftUserStatus_; }
    }
    
    public const int RightUserStatusFieldNumber = 2;
    private bool hasRightUserStatus;
    private bool rightUserStatus_;
    public bool HasRightUserStatus {
      get { return hasRightUserStatus; }
    }
    public bool RightUserStatus {
      get { return rightUserStatus_; }
    }
    
    public const int BottomUserStatusFieldNumber = 3;
    private bool hasBottomUserStatus;
    private bool bottomUserStatus_;
    public bool HasBottomUserStatus {
      get { return hasBottomUserStatus; }
    }
    public bool BottomUserStatus {
      get { return bottomUserStatus_; }
    }
    
    public const int TokenLocateFieldNumber = 4;
    private bool hasTokenLocate;
    private uint tokenLocate_;
    public bool HasTokenLocate {
      get { return hasTokenLocate; }
    }
    [global::System.CLSCompliant(false)]
    public uint TokenLocate {
      get { return tokenLocate_; }
    }
    
    public const int TotalTimeFieldNumber = 5;
    private bool hasTotalTime;
    private uint totalTime_;
    public bool HasTotalTime {
      get { return hasTotalTime; }
    }
    [global::System.CLSCompliant(false)]
    public uint TotalTime {
      get { return totalTime_; }
    }
    
    public const int SingleStepTimeFieldNumber = 6;
    private bool hasSingleStepTime;
    private uint singleStepTime_;
    public bool HasSingleStepTime {
      get { return hasSingleStepTime; }
    }
    [global::System.CLSCompliant(false)]
    public uint SingleStepTime {
      get { return singleStepTime_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasLeftUserStatus) return false;
        if (!hasRightUserStatus) return false;
        if (!hasBottomUserStatus) return false;
        if (!hasTokenLocate) return false;
        if (!hasTotalTime) return false;
        if (!hasSingleStepTime) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _gameStatusReplyFieldNames;
      if (hasLeftUserStatus) {
        output.WriteBool(1, field_names[1], LeftUserStatus);
      }
      if (hasRightUserStatus) {
        output.WriteBool(2, field_names[2], RightUserStatus);
      }
      if (hasBottomUserStatus) {
        output.WriteBool(3, field_names[0], BottomUserStatus);
      }
      if (hasTokenLocate) {
        output.WriteUInt32(4, field_names[4], TokenLocate);
      }
      if (hasTotalTime) {
        output.WriteUInt32(5, field_names[5], TotalTime);
      }
      if (hasSingleStepTime) {
        output.WriteUInt32(6, field_names[3], SingleStepTime);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasLeftUserStatus) {
        size += pb::CodedOutputStream.ComputeBoolSize(1, LeftUserStatus);
      }
      if (hasRightUserStatus) {
        size += pb::CodedOutputStream.ComputeBoolSize(2, RightUserStatus);
      }
      if (hasBottomUserStatus) {
        size += pb::CodedOutputStream.ComputeBoolSize(3, BottomUserStatus);
      }
      if (hasTokenLocate) {
        size += pb::CodedOutputStream.ComputeUInt32Size(4, TokenLocate);
      }
      if (hasTotalTime) {
        size += pb::CodedOutputStream.ComputeUInt32Size(5, TotalTime);
      }
      if (hasSingleStepTime) {
        size += pb::CodedOutputStream.ComputeUInt32Size(6, SingleStepTime);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static GameStatusReply ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameStatusReply ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameStatusReply ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameStatusReply ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameStatusReply ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameStatusReply ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GameStatusReply ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GameStatusReply ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GameStatusReply ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameStatusReply ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GameStatusReply MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GameStatusReply prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<GameStatusReply, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GameStatusReply cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GameStatusReply result;
      
      private GameStatusReply PrepareBuilder() {
        if (resultIsReadOnly) {
          GameStatusReply original = result;
          result = new GameStatusReply();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GameStatusReply MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.GameStatusReply.Descriptor; }
      }
      
      public override GameStatusReply DefaultInstanceForType {
        get { return global::MessageStruct.GameStatusReply.DefaultInstance; }
      }
      
      public override GameStatusReply BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GameStatusReply) {
          return MergeFrom((GameStatusReply) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GameStatusReply other) {
        if (other == global::MessageStruct.GameStatusReply.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasLeftUserStatus) {
          LeftUserStatus = other.LeftUserStatus;
        }
        if (other.HasRightUserStatus) {
          RightUserStatus = other.RightUserStatus;
        }
        if (other.HasBottomUserStatus) {
          BottomUserStatus = other.BottomUserStatus;
        }
        if (other.HasTokenLocate) {
          TokenLocate = other.TokenLocate;
        }
        if (other.HasTotalTime) {
          TotalTime = other.TotalTime;
        }
        if (other.HasSingleStepTime) {
          SingleStepTime = other.SingleStepTime;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_gameStatusReplyFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _gameStatusReplyFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasLeftUserStatus = input.ReadBool(ref result.leftUserStatus_);
              break;
            }
            case 16: {
              result.hasRightUserStatus = input.ReadBool(ref result.rightUserStatus_);
              break;
            }
            case 24: {
              result.hasBottomUserStatus = input.ReadBool(ref result.bottomUserStatus_);
              break;
            }
            case 32: {
              result.hasTokenLocate = input.ReadUInt32(ref result.tokenLocate_);
              break;
            }
            case 40: {
              result.hasTotalTime = input.ReadUInt32(ref result.totalTime_);
              break;
            }
            case 48: {
              result.hasSingleStepTime = input.ReadUInt32(ref result.singleStepTime_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasLeftUserStatus {
        get { return result.hasLeftUserStatus; }
      }
      public bool LeftUserStatus {
        get { return result.LeftUserStatus; }
        set { SetLeftUserStatus(value); }
      }
      public Builder SetLeftUserStatus(bool value) {
        PrepareBuilder();
        result.hasLeftUserStatus = true;
        result.leftUserStatus_ = value;
        return this;
      }
      public Builder ClearLeftUserStatus() {
        PrepareBuilder();
        result.hasLeftUserStatus = false;
        result.leftUserStatus_ = false;
        return this;
      }
      
      public bool HasRightUserStatus {
        get { return result.hasRightUserStatus; }
      }
      public bool RightUserStatus {
        get { return result.RightUserStatus; }
        set { SetRightUserStatus(value); }
      }
      public Builder SetRightUserStatus(bool value) {
        PrepareBuilder();
        result.hasRightUserStatus = true;
        result.rightUserStatus_ = value;
        return this;
      }
      public Builder ClearRightUserStatus() {
        PrepareBuilder();
        result.hasRightUserStatus = false;
        result.rightUserStatus_ = false;
        return this;
      }
      
      public bool HasBottomUserStatus {
        get { return result.hasBottomUserStatus; }
      }
      public bool BottomUserStatus {
        get { return result.BottomUserStatus; }
        set { SetBottomUserStatus(value); }
      }
      public Builder SetBottomUserStatus(bool value) {
        PrepareBuilder();
        result.hasBottomUserStatus = true;
        result.bottomUserStatus_ = value;
        return this;
      }
      public Builder ClearBottomUserStatus() {
        PrepareBuilder();
        result.hasBottomUserStatus = false;
        result.bottomUserStatus_ = false;
        return this;
      }
      
      public bool HasTokenLocate {
        get { return result.hasTokenLocate; }
      }
      [global::System.CLSCompliant(false)]
      public uint TokenLocate {
        get { return result.TokenLocate; }
        set { SetTokenLocate(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetTokenLocate(uint value) {
        PrepareBuilder();
        result.hasTokenLocate = true;
        result.tokenLocate_ = value;
        return this;
      }
      public Builder ClearTokenLocate() {
        PrepareBuilder();
        result.hasTokenLocate = false;
        result.tokenLocate_ = 0;
        return this;
      }
      
      public bool HasTotalTime {
        get { return result.hasTotalTime; }
      }
      [global::System.CLSCompliant(false)]
      public uint TotalTime {
        get { return result.TotalTime; }
        set { SetTotalTime(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetTotalTime(uint value) {
        PrepareBuilder();
        result.hasTotalTime = true;
        result.totalTime_ = value;
        return this;
      }
      public Builder ClearTotalTime() {
        PrepareBuilder();
        result.hasTotalTime = false;
        result.totalTime_ = 0;
        return this;
      }
      
      public bool HasSingleStepTime {
        get { return result.hasSingleStepTime; }
      }
      [global::System.CLSCompliant(false)]
      public uint SingleStepTime {
        get { return result.SingleStepTime; }
        set { SetSingleStepTime(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetSingleStepTime(uint value) {
        PrepareBuilder();
        result.hasSingleStepTime = true;
        result.singleStepTime_ = value;
        return this;
      }
      public Builder ClearSingleStepTime() {
        PrepareBuilder();
        result.hasSingleStepTime = false;
        result.singleStepTime_ = 0;
        return this;
      }
    }
    static GameStatusReply() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class FindPassword : pb::GeneratedMessage<FindPassword, FindPassword.Builder> {
    private FindPassword() { }
    private static readonly FindPassword defaultInstance = new FindPassword().MakeReadOnly();
    private static readonly string[] _findPasswordFieldNames = new string[] { "email", "opt" };
    private static readonly uint[] _findPasswordFieldTags = new uint[] { 10, 18 };
    public static FindPassword DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override FindPassword DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override FindPassword ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_FindPassword__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<FindPassword, FindPassword.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_FindPassword__FieldAccessorTable; }
    }
    
    public const int EmailFieldNumber = 1;
    private bool hasEmail;
    private string email_ = "";
    public bool HasEmail {
      get { return hasEmail; }
    }
    public string Email {
      get { return email_; }
    }
    
    public const int OptFieldNumber = 2;
    private bool hasOpt;
    private string opt_ = "";
    public bool HasOpt {
      get { return hasOpt; }
    }
    public string Opt {
      get { return opt_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasEmail) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _findPasswordFieldNames;
      if (hasEmail) {
        output.WriteString(1, field_names[0], Email);
      }
      if (hasOpt) {
        output.WriteString(2, field_names[1], Opt);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasEmail) {
        size += pb::CodedOutputStream.ComputeStringSize(1, Email);
      }
      if (hasOpt) {
        size += pb::CodedOutputStream.ComputeStringSize(2, Opt);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static FindPassword ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static FindPassword ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static FindPassword ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static FindPassword ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static FindPassword ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static FindPassword ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static FindPassword ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static FindPassword ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static FindPassword ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static FindPassword ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private FindPassword MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(FindPassword prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<FindPassword, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(FindPassword cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private FindPassword result;
      
      private FindPassword PrepareBuilder() {
        if (resultIsReadOnly) {
          FindPassword original = result;
          result = new FindPassword();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override FindPassword MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.FindPassword.Descriptor; }
      }
      
      public override FindPassword DefaultInstanceForType {
        get { return global::MessageStruct.FindPassword.DefaultInstance; }
      }
      
      public override FindPassword BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is FindPassword) {
          return MergeFrom((FindPassword) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(FindPassword other) {
        if (other == global::MessageStruct.FindPassword.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasEmail) {
          Email = other.Email;
        }
        if (other.HasOpt) {
          Opt = other.Opt;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_findPasswordFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _findPasswordFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasEmail = input.ReadString(ref result.email_);
              break;
            }
            case 18: {
              result.hasOpt = input.ReadString(ref result.opt_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasEmail {
        get { return result.hasEmail; }
      }
      public string Email {
        get { return result.Email; }
        set { SetEmail(value); }
      }
      public Builder SetEmail(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasEmail = true;
        result.email_ = value;
        return this;
      }
      public Builder ClearEmail() {
        PrepareBuilder();
        result.hasEmail = false;
        result.email_ = "";
        return this;
      }
      
      public bool HasOpt {
        get { return result.hasOpt; }
      }
      public string Opt {
        get { return result.Opt; }
        set { SetOpt(value); }
      }
      public Builder SetOpt(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasOpt = true;
        result.opt_ = value;
        return this;
      }
      public Builder ClearOpt() {
        PrepareBuilder();
        result.hasOpt = false;
        result.opt_ = "";
        return this;
      }
    }
    static FindPassword() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class UpdateUserInfo : pb::GeneratedMessage<UpdateUserInfo, UpdateUserInfo.Builder> {
    private UpdateUserInfo() { }
    private static readonly UpdateUserInfo defaultInstance = new UpdateUserInfo().MakeReadOnly();
    private static readonly string[] _updateUserInfoFieldNames = new string[] { "account", "ex_email", "head_image", "password", "phone", "user_name" };
    private static readonly uint[] _updateUserInfoFieldTags = new uint[] { 18, 34, 50, 26, 42, 10 };
    public static UpdateUserInfo DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override UpdateUserInfo DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override UpdateUserInfo ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_UpdateUserInfo__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<UpdateUserInfo, UpdateUserInfo.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_UpdateUserInfo__FieldAccessorTable; }
    }
    
    public const int UserNameFieldNumber = 1;
    private bool hasUserName;
    private string userName_ = "";
    public bool HasUserName {
      get { return hasUserName; }
    }
    public string UserName {
      get { return userName_; }
    }
    
    public const int AccountFieldNumber = 2;
    private bool hasAccount;
    private string account_ = "";
    public bool HasAccount {
      get { return hasAccount; }
    }
    public string Account {
      get { return account_; }
    }
    
    public const int PasswordFieldNumber = 3;
    private bool hasPassword;
    private string password_ = "";
    public bool HasPassword {
      get { return hasPassword; }
    }
    public string Password {
      get { return password_; }
    }
    
    public const int ExEmailFieldNumber = 4;
    private bool hasExEmail;
    private string exEmail_ = "";
    public bool HasExEmail {
      get { return hasExEmail; }
    }
    public string ExEmail {
      get { return exEmail_; }
    }
    
    public const int PhoneFieldNumber = 5;
    private bool hasPhone;
    private string phone_ = "";
    public bool HasPhone {
      get { return hasPhone; }
    }
    public string Phone {
      get { return phone_; }
    }
    
    public const int HeadImageFieldNumber = 6;
    private bool hasHeadImage;
    private pb::ByteString headImage_ = pb::ByteString.Empty;
    public bool HasHeadImage {
      get { return hasHeadImage; }
    }
    public pb::ByteString HeadImage {
      get { return headImage_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasUserName) return false;
        if (!hasAccount) return false;
        if (!hasPassword) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _updateUserInfoFieldNames;
      if (hasUserName) {
        output.WriteString(1, field_names[5], UserName);
      }
      if (hasAccount) {
        output.WriteString(2, field_names[0], Account);
      }
      if (hasPassword) {
        output.WriteString(3, field_names[3], Password);
      }
      if (hasExEmail) {
        output.WriteString(4, field_names[1], ExEmail);
      }
      if (hasPhone) {
        output.WriteString(5, field_names[4], Phone);
      }
      if (hasHeadImage) {
        output.WriteBytes(6, field_names[2], HeadImage);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasUserName) {
        size += pb::CodedOutputStream.ComputeStringSize(1, UserName);
      }
      if (hasAccount) {
        size += pb::CodedOutputStream.ComputeStringSize(2, Account);
      }
      if (hasPassword) {
        size += pb::CodedOutputStream.ComputeStringSize(3, Password);
      }
      if (hasExEmail) {
        size += pb::CodedOutputStream.ComputeStringSize(4, ExEmail);
      }
      if (hasPhone) {
        size += pb::CodedOutputStream.ComputeStringSize(5, Phone);
      }
      if (hasHeadImage) {
        size += pb::CodedOutputStream.ComputeBytesSize(6, HeadImage);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static UpdateUserInfo ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static UpdateUserInfo ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static UpdateUserInfo ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static UpdateUserInfo ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static UpdateUserInfo ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static UpdateUserInfo ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static UpdateUserInfo ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static UpdateUserInfo ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static UpdateUserInfo ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static UpdateUserInfo ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private UpdateUserInfo MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(UpdateUserInfo prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<UpdateUserInfo, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(UpdateUserInfo cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private UpdateUserInfo result;
      
      private UpdateUserInfo PrepareBuilder() {
        if (resultIsReadOnly) {
          UpdateUserInfo original = result;
          result = new UpdateUserInfo();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override UpdateUserInfo MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.UpdateUserInfo.Descriptor; }
      }
      
      public override UpdateUserInfo DefaultInstanceForType {
        get { return global::MessageStruct.UpdateUserInfo.DefaultInstance; }
      }
      
      public override UpdateUserInfo BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is UpdateUserInfo) {
          return MergeFrom((UpdateUserInfo) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(UpdateUserInfo other) {
        if (other == global::MessageStruct.UpdateUserInfo.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasUserName) {
          UserName = other.UserName;
        }
        if (other.HasAccount) {
          Account = other.Account;
        }
        if (other.HasPassword) {
          Password = other.Password;
        }
        if (other.HasExEmail) {
          ExEmail = other.ExEmail;
        }
        if (other.HasPhone) {
          Phone = other.Phone;
        }
        if (other.HasHeadImage) {
          HeadImage = other.HeadImage;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_updateUserInfoFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _updateUserInfoFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasUserName = input.ReadString(ref result.userName_);
              break;
            }
            case 18: {
              result.hasAccount = input.ReadString(ref result.account_);
              break;
            }
            case 26: {
              result.hasPassword = input.ReadString(ref result.password_);
              break;
            }
            case 34: {
              result.hasExEmail = input.ReadString(ref result.exEmail_);
              break;
            }
            case 42: {
              result.hasPhone = input.ReadString(ref result.phone_);
              break;
            }
            case 50: {
              result.hasHeadImage = input.ReadBytes(ref result.headImage_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasUserName {
        get { return result.hasUserName; }
      }
      public string UserName {
        get { return result.UserName; }
        set { SetUserName(value); }
      }
      public Builder SetUserName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasUserName = true;
        result.userName_ = value;
        return this;
      }
      public Builder ClearUserName() {
        PrepareBuilder();
        result.hasUserName = false;
        result.userName_ = "";
        return this;
      }
      
      public bool HasAccount {
        get { return result.hasAccount; }
      }
      public string Account {
        get { return result.Account; }
        set { SetAccount(value); }
      }
      public Builder SetAccount(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasAccount = true;
        result.account_ = value;
        return this;
      }
      public Builder ClearAccount() {
        PrepareBuilder();
        result.hasAccount = false;
        result.account_ = "";
        return this;
      }
      
      public bool HasPassword {
        get { return result.hasPassword; }
      }
      public string Password {
        get { return result.Password; }
        set { SetPassword(value); }
      }
      public Builder SetPassword(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPassword = true;
        result.password_ = value;
        return this;
      }
      public Builder ClearPassword() {
        PrepareBuilder();
        result.hasPassword = false;
        result.password_ = "";
        return this;
      }
      
      public bool HasExEmail {
        get { return result.hasExEmail; }
      }
      public string ExEmail {
        get { return result.ExEmail; }
        set { SetExEmail(value); }
      }
      public Builder SetExEmail(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasExEmail = true;
        result.exEmail_ = value;
        return this;
      }
      public Builder ClearExEmail() {
        PrepareBuilder();
        result.hasExEmail = false;
        result.exEmail_ = "";
        return this;
      }
      
      public bool HasPhone {
        get { return result.hasPhone; }
      }
      public string Phone {
        get { return result.Phone; }
        set { SetPhone(value); }
      }
      public Builder SetPhone(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPhone = true;
        result.phone_ = value;
        return this;
      }
      public Builder ClearPhone() {
        PrepareBuilder();
        result.hasPhone = false;
        result.phone_ = "";
        return this;
      }
      
      public bool HasHeadImage {
        get { return result.hasHeadImage; }
      }
      public pb::ByteString HeadImage {
        get { return result.HeadImage; }
        set { SetHeadImage(value); }
      }
      public Builder SetHeadImage(pb::ByteString value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasHeadImage = true;
        result.headImage_ = value;
        return this;
      }
      public Builder ClearHeadImage() {
        PrepareBuilder();
        result.hasHeadImage = false;
        result.headImage_ = pb::ByteString.Empty;
        return this;
      }
    }
    static UpdateUserInfo() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class AdPictureItemReply : pb::GeneratedMessage<AdPictureItemReply, AdPictureItemReply.Builder> {
    private AdPictureItemReply() { }
    private static readonly AdPictureItemReply defaultInstance = new AdPictureItemReply().MakeReadOnly();
    private static readonly string[] _adPictureItemReplyFieldNames = new string[] { "existed", "image_hashcode", "image_id", "image_name", "image_size", "image_type", "url" };
    private static readonly uint[] _adPictureItemReplyFieldTags = new uint[] { 16, 42, 8, 34, 56, 26, 50 };
    public static AdPictureItemReply DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override AdPictureItemReply DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override AdPictureItemReply ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_AdPictureItemReply__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<AdPictureItemReply, AdPictureItemReply.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_AdPictureItemReply__FieldAccessorTable; }
    }
    
    public const int ImageIdFieldNumber = 1;
    private bool hasImageId;
    private uint imageId_;
    public bool HasImageId {
      get { return hasImageId; }
    }
    [global::System.CLSCompliant(false)]
    public uint ImageId {
      get { return imageId_; }
    }
    
    public const int ExistedFieldNumber = 2;
    private bool hasExisted;
    private bool existed_;
    public bool HasExisted {
      get { return hasExisted; }
    }
    public bool Existed {
      get { return existed_; }
    }
    
    public const int ImageTypeFieldNumber = 3;
    private bool hasImageType;
    private string imageType_ = "";
    public bool HasImageType {
      get { return hasImageType; }
    }
    public string ImageType {
      get { return imageType_; }
    }
    
    public const int ImageNameFieldNumber = 4;
    private bool hasImageName;
    private string imageName_ = "";
    public bool HasImageName {
      get { return hasImageName; }
    }
    public string ImageName {
      get { return imageName_; }
    }
    
    public const int ImageHashcodeFieldNumber = 5;
    private bool hasImageHashcode;
    private string imageHashcode_ = "";
    public bool HasImageHashcode {
      get { return hasImageHashcode; }
    }
    public string ImageHashcode {
      get { return imageHashcode_; }
    }
    
    public const int UrlFieldNumber = 6;
    private bool hasUrl;
    private string url_ = "";
    public bool HasUrl {
      get { return hasUrl; }
    }
    public string Url {
      get { return url_; }
    }
    
    public const int ImageSizeFieldNumber = 7;
    private bool hasImageSize;
    private uint imageSize_;
    public bool HasImageSize {
      get { return hasImageSize; }
    }
    [global::System.CLSCompliant(false)]
    public uint ImageSize {
      get { return imageSize_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasImageId) return false;
        if (!hasExisted) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _adPictureItemReplyFieldNames;
      if (hasImageId) {
        output.WriteUInt32(1, field_names[2], ImageId);
      }
      if (hasExisted) {
        output.WriteBool(2, field_names[0], Existed);
      }
      if (hasImageType) {
        output.WriteString(3, field_names[5], ImageType);
      }
      if (hasImageName) {
        output.WriteString(4, field_names[3], ImageName);
      }
      if (hasImageHashcode) {
        output.WriteString(5, field_names[1], ImageHashcode);
      }
      if (hasUrl) {
        output.WriteString(6, field_names[6], Url);
      }
      if (hasImageSize) {
        output.WriteUInt32(7, field_names[4], ImageSize);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasImageId) {
        size += pb::CodedOutputStream.ComputeUInt32Size(1, ImageId);
      }
      if (hasExisted) {
        size += pb::CodedOutputStream.ComputeBoolSize(2, Existed);
      }
      if (hasImageType) {
        size += pb::CodedOutputStream.ComputeStringSize(3, ImageType);
      }
      if (hasImageName) {
        size += pb::CodedOutputStream.ComputeStringSize(4, ImageName);
      }
      if (hasImageHashcode) {
        size += pb::CodedOutputStream.ComputeStringSize(5, ImageHashcode);
      }
      if (hasUrl) {
        size += pb::CodedOutputStream.ComputeStringSize(6, Url);
      }
      if (hasImageSize) {
        size += pb::CodedOutputStream.ComputeUInt32Size(7, ImageSize);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static AdPictureItemReply ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AdPictureItemReply ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AdPictureItemReply ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AdPictureItemReply ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AdPictureItemReply ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AdPictureItemReply ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static AdPictureItemReply ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static AdPictureItemReply ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static AdPictureItemReply ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AdPictureItemReply ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private AdPictureItemReply MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(AdPictureItemReply prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<AdPictureItemReply, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(AdPictureItemReply cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private AdPictureItemReply result;
      
      private AdPictureItemReply PrepareBuilder() {
        if (resultIsReadOnly) {
          AdPictureItemReply original = result;
          result = new AdPictureItemReply();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override AdPictureItemReply MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.AdPictureItemReply.Descriptor; }
      }
      
      public override AdPictureItemReply DefaultInstanceForType {
        get { return global::MessageStruct.AdPictureItemReply.DefaultInstance; }
      }
      
      public override AdPictureItemReply BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is AdPictureItemReply) {
          return MergeFrom((AdPictureItemReply) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(AdPictureItemReply other) {
        if (other == global::MessageStruct.AdPictureItemReply.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasImageId) {
          ImageId = other.ImageId;
        }
        if (other.HasExisted) {
          Existed = other.Existed;
        }
        if (other.HasImageType) {
          ImageType = other.ImageType;
        }
        if (other.HasImageName) {
          ImageName = other.ImageName;
        }
        if (other.HasImageHashcode) {
          ImageHashcode = other.ImageHashcode;
        }
        if (other.HasUrl) {
          Url = other.Url;
        }
        if (other.HasImageSize) {
          ImageSize = other.ImageSize;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_adPictureItemReplyFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _adPictureItemReplyFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasImageId = input.ReadUInt32(ref result.imageId_);
              break;
            }
            case 16: {
              result.hasExisted = input.ReadBool(ref result.existed_);
              break;
            }
            case 26: {
              result.hasImageType = input.ReadString(ref result.imageType_);
              break;
            }
            case 34: {
              result.hasImageName = input.ReadString(ref result.imageName_);
              break;
            }
            case 42: {
              result.hasImageHashcode = input.ReadString(ref result.imageHashcode_);
              break;
            }
            case 50: {
              result.hasUrl = input.ReadString(ref result.url_);
              break;
            }
            case 56: {
              result.hasImageSize = input.ReadUInt32(ref result.imageSize_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasImageId {
        get { return result.hasImageId; }
      }
      [global::System.CLSCompliant(false)]
      public uint ImageId {
        get { return result.ImageId; }
        set { SetImageId(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetImageId(uint value) {
        PrepareBuilder();
        result.hasImageId = true;
        result.imageId_ = value;
        return this;
      }
      public Builder ClearImageId() {
        PrepareBuilder();
        result.hasImageId = false;
        result.imageId_ = 0;
        return this;
      }
      
      public bool HasExisted {
        get { return result.hasExisted; }
      }
      public bool Existed {
        get { return result.Existed; }
        set { SetExisted(value); }
      }
      public Builder SetExisted(bool value) {
        PrepareBuilder();
        result.hasExisted = true;
        result.existed_ = value;
        return this;
      }
      public Builder ClearExisted() {
        PrepareBuilder();
        result.hasExisted = false;
        result.existed_ = false;
        return this;
      }
      
      public bool HasImageType {
        get { return result.hasImageType; }
      }
      public string ImageType {
        get { return result.ImageType; }
        set { SetImageType(value); }
      }
      public Builder SetImageType(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasImageType = true;
        result.imageType_ = value;
        return this;
      }
      public Builder ClearImageType() {
        PrepareBuilder();
        result.hasImageType = false;
        result.imageType_ = "";
        return this;
      }
      
      public bool HasImageName {
        get { return result.hasImageName; }
      }
      public string ImageName {
        get { return result.ImageName; }
        set { SetImageName(value); }
      }
      public Builder SetImageName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasImageName = true;
        result.imageName_ = value;
        return this;
      }
      public Builder ClearImageName() {
        PrepareBuilder();
        result.hasImageName = false;
        result.imageName_ = "";
        return this;
      }
      
      public bool HasImageHashcode {
        get { return result.hasImageHashcode; }
      }
      public string ImageHashcode {
        get { return result.ImageHashcode; }
        set { SetImageHashcode(value); }
      }
      public Builder SetImageHashcode(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasImageHashcode = true;
        result.imageHashcode_ = value;
        return this;
      }
      public Builder ClearImageHashcode() {
        PrepareBuilder();
        result.hasImageHashcode = false;
        result.imageHashcode_ = "";
        return this;
      }
      
      public bool HasUrl {
        get { return result.hasUrl; }
      }
      public string Url {
        get { return result.Url; }
        set { SetUrl(value); }
      }
      public Builder SetUrl(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasUrl = true;
        result.url_ = value;
        return this;
      }
      public Builder ClearUrl() {
        PrepareBuilder();
        result.hasUrl = false;
        result.url_ = "";
        return this;
      }
      
      public bool HasImageSize {
        get { return result.hasImageSize; }
      }
      [global::System.CLSCompliant(false)]
      public uint ImageSize {
        get { return result.ImageSize; }
        set { SetImageSize(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetImageSize(uint value) {
        PrepareBuilder();
        result.hasImageSize = true;
        result.imageSize_ = value;
        return this;
      }
      public Builder ClearImageSize() {
        PrepareBuilder();
        result.hasImageSize = false;
        result.imageSize_ = 0;
        return this;
      }
    }
    static AdPictureItemReply() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class AdPictureReq : pb::GeneratedMessage<AdPictureReq, AdPictureReq.Builder> {
    private AdPictureReq() { }
    private static readonly AdPictureReq defaultInstance = new AdPictureReq().MakeReadOnly();
    private static readonly string[] _adPictureReqFieldNames = new string[] { "image_id", "last_one", "req_type" };
    private static readonly uint[] _adPictureReqFieldTags = new uint[] { 8, 24, 16 };
    public static AdPictureReq DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override AdPictureReq DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override AdPictureReq ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_AdPictureReq__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<AdPictureReq, AdPictureReq.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_AdPictureReq__FieldAccessorTable; }
    }
    
    public const int ImageIdFieldNumber = 1;
    private bool hasImageId;
    private uint imageId_;
    public bool HasImageId {
      get { return hasImageId; }
    }
    [global::System.CLSCompliant(false)]
    public uint ImageId {
      get { return imageId_; }
    }
    
    public const int ReqTypeFieldNumber = 2;
    private bool hasReqType;
    private uint reqType_;
    public bool HasReqType {
      get { return hasReqType; }
    }
    [global::System.CLSCompliant(false)]
    public uint ReqType {
      get { return reqType_; }
    }
    
    public const int LastOneFieldNumber = 3;
    private bool hasLastOne;
    private bool lastOne_;
    public bool HasLastOne {
      get { return hasLastOne; }
    }
    public bool LastOne {
      get { return lastOne_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasImageId) return false;
        if (!hasReqType) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _adPictureReqFieldNames;
      if (hasImageId) {
        output.WriteUInt32(1, field_names[0], ImageId);
      }
      if (hasReqType) {
        output.WriteUInt32(2, field_names[2], ReqType);
      }
      if (hasLastOne) {
        output.WriteBool(3, field_names[1], LastOne);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasImageId) {
        size += pb::CodedOutputStream.ComputeUInt32Size(1, ImageId);
      }
      if (hasReqType) {
        size += pb::CodedOutputStream.ComputeUInt32Size(2, ReqType);
      }
      if (hasLastOne) {
        size += pb::CodedOutputStream.ComputeBoolSize(3, LastOne);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static AdPictureReq ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AdPictureReq ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AdPictureReq ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AdPictureReq ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AdPictureReq ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AdPictureReq ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static AdPictureReq ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static AdPictureReq ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static AdPictureReq ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AdPictureReq ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private AdPictureReq MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(AdPictureReq prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<AdPictureReq, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(AdPictureReq cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private AdPictureReq result;
      
      private AdPictureReq PrepareBuilder() {
        if (resultIsReadOnly) {
          AdPictureReq original = result;
          result = new AdPictureReq();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override AdPictureReq MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.AdPictureReq.Descriptor; }
      }
      
      public override AdPictureReq DefaultInstanceForType {
        get { return global::MessageStruct.AdPictureReq.DefaultInstance; }
      }
      
      public override AdPictureReq BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is AdPictureReq) {
          return MergeFrom((AdPictureReq) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(AdPictureReq other) {
        if (other == global::MessageStruct.AdPictureReq.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasImageId) {
          ImageId = other.ImageId;
        }
        if (other.HasReqType) {
          ReqType = other.ReqType;
        }
        if (other.HasLastOne) {
          LastOne = other.LastOne;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_adPictureReqFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _adPictureReqFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasImageId = input.ReadUInt32(ref result.imageId_);
              break;
            }
            case 16: {
              result.hasReqType = input.ReadUInt32(ref result.reqType_);
              break;
            }
            case 24: {
              result.hasLastOne = input.ReadBool(ref result.lastOne_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasImageId {
        get { return result.hasImageId; }
      }
      [global::System.CLSCompliant(false)]
      public uint ImageId {
        get { return result.ImageId; }
        set { SetImageId(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetImageId(uint value) {
        PrepareBuilder();
        result.hasImageId = true;
        result.imageId_ = value;
        return this;
      }
      public Builder ClearImageId() {
        PrepareBuilder();
        result.hasImageId = false;
        result.imageId_ = 0;
        return this;
      }
      
      public bool HasReqType {
        get { return result.hasReqType; }
      }
      [global::System.CLSCompliant(false)]
      public uint ReqType {
        get { return result.ReqType; }
        set { SetReqType(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetReqType(uint value) {
        PrepareBuilder();
        result.hasReqType = true;
        result.reqType_ = value;
        return this;
      }
      public Builder ClearReqType() {
        PrepareBuilder();
        result.hasReqType = false;
        result.reqType_ = 0;
        return this;
      }
      
      public bool HasLastOne {
        get { return result.hasLastOne; }
      }
      public bool LastOne {
        get { return result.LastOne; }
        set { SetLastOne(value); }
      }
      public Builder SetLastOne(bool value) {
        PrepareBuilder();
        result.hasLastOne = true;
        result.lastOne_ = value;
        return this;
      }
      public Builder ClearLastOne() {
        PrepareBuilder();
        result.hasLastOne = false;
        result.lastOne_ = false;
        return this;
      }
    }
    static AdPictureReq() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class AdPictureContentReply : pb::GeneratedMessage<AdPictureContentReply, AdPictureContentReply.Builder> {
    private AdPictureContentReply() { }
    private static readonly AdPictureContentReply defaultInstance = new AdPictureContentReply().MakeReadOnly();
    private static readonly string[] _adPictureContentReplyFieldNames = new string[] { "content", "ended" };
    private static readonly uint[] _adPictureContentReplyFieldTags = new uint[] { 18, 8 };
    public static AdPictureContentReply DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override AdPictureContentReply DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override AdPictureContentReply ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_AdPictureContentReply__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<AdPictureContentReply, AdPictureContentReply.Builder> InternalFieldAccessors {
      get { return global::MessageStruct.Message.internal__static_MessageStruct_AdPictureContentReply__FieldAccessorTable; }
    }
    
    public const int EndedFieldNumber = 1;
    private bool hasEnded;
    private bool ended_;
    public bool HasEnded {
      get { return hasEnded; }
    }
    public bool Ended {
      get { return ended_; }
    }
    
    public const int ContentFieldNumber = 2;
    private bool hasContent;
    private pb::ByteString content_ = pb::ByteString.Empty;
    public bool HasContent {
      get { return hasContent; }
    }
    public pb::ByteString Content {
      get { return content_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasEnded) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _adPictureContentReplyFieldNames;
      if (hasEnded) {
        output.WriteBool(1, field_names[1], Ended);
      }
      if (hasContent) {
        output.WriteBytes(2, field_names[0], Content);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasEnded) {
        size += pb::CodedOutputStream.ComputeBoolSize(1, Ended);
      }
      if (hasContent) {
        size += pb::CodedOutputStream.ComputeBytesSize(2, Content);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static AdPictureContentReply ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AdPictureContentReply ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AdPictureContentReply ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AdPictureContentReply ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AdPictureContentReply ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AdPictureContentReply ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static AdPictureContentReply ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static AdPictureContentReply ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static AdPictureContentReply ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AdPictureContentReply ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private AdPictureContentReply MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(AdPictureContentReply prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<AdPictureContentReply, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(AdPictureContentReply cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private AdPictureContentReply result;
      
      private AdPictureContentReply PrepareBuilder() {
        if (resultIsReadOnly) {
          AdPictureContentReply original = result;
          result = new AdPictureContentReply();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override AdPictureContentReply MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::MessageStruct.AdPictureContentReply.Descriptor; }
      }
      
      public override AdPictureContentReply DefaultInstanceForType {
        get { return global::MessageStruct.AdPictureContentReply.DefaultInstance; }
      }
      
      public override AdPictureContentReply BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is AdPictureContentReply) {
          return MergeFrom((AdPictureContentReply) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(AdPictureContentReply other) {
        if (other == global::MessageStruct.AdPictureContentReply.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasEnded) {
          Ended = other.Ended;
        }
        if (other.HasContent) {
          Content = other.Content;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_adPictureContentReplyFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _adPictureContentReplyFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasEnded = input.ReadBool(ref result.ended_);
              break;
            }
            case 18: {
              result.hasContent = input.ReadBytes(ref result.content_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasEnded {
        get { return result.hasEnded; }
      }
      public bool Ended {
        get { return result.Ended; }
        set { SetEnded(value); }
      }
      public Builder SetEnded(bool value) {
        PrepareBuilder();
        result.hasEnded = true;
        result.ended_ = value;
        return this;
      }
      public Builder ClearEnded() {
        PrepareBuilder();
        result.hasEnded = false;
        result.ended_ = false;
        return this;
      }
      
      public bool HasContent {
        get { return result.hasContent; }
      }
      public pb::ByteString Content {
        get { return result.Content; }
        set { SetContent(value); }
      }
      public Builder SetContent(pb::ByteString value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasContent = true;
        result.content_ = value;
        return this;
      }
      public Builder ClearContent() {
        PrepareBuilder();
        result.hasContent = false;
        result.content_ = pb::ByteString.Empty;
        return this;
      }
    }
    static AdPictureContentReply() {
      object.ReferenceEquals(global::MessageStruct.Message.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
